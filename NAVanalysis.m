(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



saveAllPlots = False; (*Change this to True to save ALL the plots that are generated in THIS notebook. It does not include NAVobservational plots. Saves for specific models are in their respective sections.*)
saveNAVobservationalPlots = False;
saveNAVobservationalTables = False;

pathBaseDirectory = NotebookDirectory[];
pathOutputDirectory = FileNameJoin[{pathBaseDirectory, "Output"}];
pathAuxDirectory = FileNameJoin[{pathBaseDirectory, "AuxiliaryData"}];

datasetExpVdiskNoBulge = Import[FileNameJoin[{pathOutputDirectory, "datasetExpVdiskNoBulge.m"}]]; (*Loads the exponential approximations for the stellar disk as a DataSet*)
datasetExpVgasNoBulge = Import[FileNameJoin[{pathOutputDirectory, "datasetExpVgasNoBulge.m"}]]; (*The same as above, but for the gas.*)

SetDirectory @ pathBaseDirectory;

Needs @ "NAVbaseCode`";
Get @ "NAVoptions.wl";
Get @ "NAVobservational.wl";
Get @ "NAVauxiliaryFunctions.wl";
Get["MDC14aux.mx", Path -> pathAuxDirectory] // Quiet; (*If something goes wrong, this file will be generated*)

SetDirectory @ pathOutputDirectory;

savePreviousPlot[fileName_] := If[saveThisPlot || saveAllPlots, 
  Echo @ Export[ToString @ fileName, %]; saveThisPlot = False
];


Clear[b, loga, model, logR];
model = b logR - loga;
{b , loga} = {b, loga} /. FindFit[Re[{Log10[#1] , Log10[#2]} & @@@ Flatten[gdR[{Rad, Vmiss2}],1]],  model , {b , loga} , logR]


Show[
  plotBlueZero[
    {Log10[#1], Log10[#2]} & @@@ Flatten[gdR[{Rad, Vmiss2}], 1], 
    PlotRange-> {{0,2}, {1,5.5}}
  ],
  Plot[{Log10[10^logR/0.0015], model}, {logR, 0, 3}, PlotStyle->{{Black, Dashed}, Black}]
]

Export["DeltaV2analysis.pdf", %]


Clear[ac];
list2restrictedRARRot = Select[list2RARRot, 0.2 <  #[[1]] < 0.9 &] ;
{ac} ={ac} /. FindFit[list2restrictedRARRot,  r^ac , ac , r]

Clear[a, b, c, d, e, f, g, h];

list = Table[{r, list1InterpCurvesRAR[[4]][r]}, {r,0.2, 0.9, 0.05}];
{c, d} = {c , d}/. FindFit[list, {2 r^c -  r^d},  {c, d}, r]

list = Table[{r, list1InterpCurvesRAR[[3]][r]}, {r,0.2, 0.9, 0.05}];
{b} = {b}/. FindFit[list, r^b,  {b}, r]

list = Table[{r, list1InterpCurvesRAR[[2]][r]}, {r,0.2, 0.9, 0.05}];
{e, f} = {e, f}/. FindFit[list, {2 r^e -  r^f},  {e, f}, r]

list = Table[{r, list1InterpCurvesRAR[[1]][r]}, {r,0.2, 0.9, 0.05}];
{g} = {g}/. FindFit[list, r^g ,  {g}, r]

plotPowerLawModel = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        2 rn^c - rn^d, 
        2 rn^e -  rn^f,  
        rn^b, 
        rn^g
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Red, 0.2], Thickness @ 0.003},
        {Lighter[Red, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Red, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Red, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ],
    Plot[rn^ac, {rn,0,1}, PlotStyle -> {Black, Dashed}]
  }
]

Export["plotPowerLawModel.pdf", %]


\[Delta]Varctan[rn_, rtn_] = ArcTan[rn/rtn]^2/ArcTan[1/rtn]^2;

\[Delta]VarctanLimit1[rn_] = Limit[\[Delta]Varctan[rn, rtn], rtn -> \[Infinity]];
\[Delta]VarctanLimit2[rn_] = Limit[\[Delta]Varctan[rn, rtn], rtn -> 0];
  

plotArctanGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]VarctanLimit1[rn], 
        \[Delta]VarctanLimit2[rn]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotArctanGrayRed:"];
Print@plotArctanGrayRed;




(* DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];

Clear[chi2Upper, chi2Lower];
chi2Upper[rtn_?NumberQ, n\[Sigma]_] := NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]Varctan[rn,rtn])^2, 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];

chi2Lower[rtn_?NumberQ, n\[Sigma]_] := NIntegrate[
  (lowerBound[n\[Sigma]][rn] - \[Delta]Varctan[rn,rtn])^2, 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing"-> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];


(* EXECUTION *)

Echo["Performing the optimization."];

rtnUpper[2] = rtn /. NMinimize[{chi2Upper[rtn,2],rtn>0.001},{rtn,0,10}][[2]];
rtnUpper[1] = rtn /. NMinimize[{chi2Upper[rtn,1],rtn>0.001},{rtn,0,10}][[2]];
rtnLower[2] = rtn /. NMinimize[{chi2Lower[rtn,2],rtn>0.001},{rtn,0,10}][[2]];
rtnLower[1] = rtn /. NMinimize[{chi2Lower[rtn,1],rtn>0.001},{rtn,0,10}][[2]];

Echo[{rtnUpper[1], rtnLower[1]}, "rtn 1\[Sigma] bounds: "];
Echo[{rtnUpper[2], rtnLower[2]}, "rtn 2\[Sigma] bounds: "];

plotArctanGlobalBestFit = Show[
  {
    plotArctanGrayRed,
    Plot[
      {
        \[Delta]Varctan[rn, rtnUpper @ 2],
        \[Delta]Varctan[rn, rtnUpper @ 1],
        \[Delta]Varctan[rn, rtnLower @ 2],
        \[Delta]Varctan[rn, rtnLower @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotArctanGlobalBestFit:"];
Print@plotArctanGlobalBestFit;

Export["plotArctanGlobalBestFit.pdf", plotArctanGlobalBestFit];


\[Rho]brkt[rn_, rcn_, \[Rho]0_] = \[Rho]0/((1+rn/rcn)(1+rn^2/rcn^2));
Mbrkt[rn_, rcn_, \[Rho]0_] = 4 \[Pi] Rmax^3  Integrate[\[Rho]brkt[rnprime,rcn,\[Rho]0] rnprime^2,{rnprime,0,rn}, Assumptions-> {rn>0, rcn>0}];

VVbrkt[rn_, rcn_, \[Rho]0_, Rmax_] = (G / Rmax) * Mbrkt[rn, rcn, \[Rho]0] / rn;

\[Delta]Vbrkt[rn_, rcn_] = FullSimplify[
  VVbrkt[rn, rcn, \[Rho]0, Rmax] / VVbrkt[1, rcn, \[Rho]0, Rmax],
  Assumptions -> {0 < rn < 1, 0 < rcn < 1, 0 < Rmax}
];

plotBurkertGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]Vbrkt[rn, 1000], 
        \[Delta]Vbrkt[rn, 0.001]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotBurkertGrayRed:"];
Print@plotBurkertGrayRed;




Clear[chi2Upper, chi2Lower];
chi2Upper[rcn_?NumberQ, n\[Sigma]_]:= (*chi2Upper[rcn, n\[Sigma]] =*) NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]Vbrkt[rn,rcn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];

chi2Lower[rcn_?NumberQ, n\[Sigma]_]:= chi2Lower[rcn, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]Vbrkt[rn,rcn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing"-> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.01;
rnEnd=0.99;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

rcnUpper[2] = rcn /. NMinimize[{chi2Upper[rcn,2],rcn>0},{rcn,0,10}][[2]];
rcnUpper[1] = rcn /. NMinimize[{chi2Upper[rcn,1],rcn>0},{rcn,0,10}][[2]];
rcnLower[2] = rcn /. NMinimize[{chi2Lower[rcn,2],rcn>0},{rcn,0,10}][[2]];
rcnLower[1] = rcn /. NMinimize[{chi2Lower[rcn,1],rcn>0},{rcn,0,10}][[2]];

Echo[{rcnUpper[1], rcnLower[1]}, "rcn 1\[Sigma] bounds: "];
Echo[{rcnUpper[2], rcnLower[2]}, "rcn 2\[Sigma] bounds: "];

plotBurkertGlobalBestFit = Show[
  {
    plotBurkertGrayRed,
    Plot[
      {
        \[Delta]Vbrkt[rn, rcnUpper @ 2],
        \[Delta]Vbrkt[rn, rcnUpper @ 1],
        \[Delta]Vbrkt[rn, rcnLower @ 2],
        \[Delta]Vbrkt[rn, rcnLower @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotBurkertGlobalBestFit:"];
Print@plotBurkertGlobalBestFit;

Export["plotBurkertGlobalBestFit.pdf", plotBurkertGlobalBestFit];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rcnLowerLimit, rcnUpperLimit];

statusHistogram[nSigmas_, rcnLowerLimit_, rcnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rc[i_] := globalData[[i, colrc]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrcAll = Table[{Rmax @ i, rc @ i}, {i, 1, 175}];
  RmaxXrc = Delete[RmaxXrcAll, posExcluded];
  rcnDataAll =  (Divide @@@ RmaxXrcAll)^-1;
  rcnData =  (Divide @@@ RmaxXrc)^-1;
  
  rcnDataWithoutOutliers = Select[rcnData, rcnLowerLimit < # < rcnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rcnDataWithoutOutliers, 
    silvermanBw[rcnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist,x],
      {x, 0, 3, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist,x],
    {x, 0, 3},
    {y,0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{0., 3}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rcnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist,x]==pdfValuesForContours[[i]], #
    ] & /@ {{x,0,maxPDF}, {x,maxPDF,3}},
    FindRoot::brmp
  ];

  {rcnLow @ 1, rcnHigh @ 1} = x /. rcnRootsSigma[1];
  {rcnLow @ 2, rcnHigh @ 2} = x /. Quiet[rcnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{rcnUpper @ nSigmas, 0}, {rcnUpper @ nSigmas, 100}},
    Line @ {{rcnLower @ nSigmas, 0}, {rcnLower @ nSigmas, 100}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rcnLow @ nSigmas, 0}, {rcnLow @ nSigmas, 100}},
    Line @ {{rcnHigh @ nSigmas, 0}, {rcnHigh @ nSigmas, 100}}
  };

  rcnDistributionHistogram := Histogram[
    rcnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{0, 3}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rcnLow@nSigmas, rcnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{rcnUpper@nSigmas, rcnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rcnLowerLimit, rcnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rcnDistributionHistogram, nPlot[PDF[dist,x], {x,0,3}, PlotRange -> All]}]
];

statusHistogram[1, 0, 100];

statusHistogram[2,0,100];


\[Rho]nfw[rn_, rsn_, \[Rho]s_] = \[Rho]s/(rn/rsn (1+rn/rsn)^2);
Mnfw[rn_, rsn_, \[Rho]s_] = 4 \[Pi] Rmax^3  Integrate[\[Rho]nfw[rnprime, rsn, \[Rho]s] rnprime^2, {rnprime, 0, rn}, Assumptions-> {rn>0, rsn>0}];

VVnfw[rn_, rsn_, \[Rho]s_, Rmax_] = (G / Rmax) * Mnfw[rn, rsn, \[Rho]s] / rn;

\[Delta]Vnfw[rn_, rsn_] = FullSimplify[
  VVnfw[rn, rsn, \[Rho]s, Rmax] / VVnfw[1, rsn, \[Rho]s, Rmax],
  Assumptions -> {0 < rn < 1, 0 < rsn < 1, 0 < Rmax}
];


(*Limiting \[Delta]Vnfw cases*)

\[Delta]VnfwLargeRsn[rn_] = Limit[\[Delta]Vnfw[rn, rsn], rsn -> \[Infinity]];
\[Delta]VnfwSmallRsn[rn_] = Limit[\[Delta]Vnfw[rn, rsn], rsn -> 0];

plotNFWlimitingCases = Show[
  {
    plotBackground[1.5],
    Plot[
      {
        \[Delta]VnfwLargeRsn[rn], 
        \[Delta]VnfwSmallRsn[rn]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
]

plotNFWlimitingCasesWbackground = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]VnfwLargeRsn[rn], 
        \[Delta]VnfwSmallRsn[rn]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Print@plotNFWlimitingCasesWbackground;




plotNFWGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]Vnfw[rn, 1000], 
        \[Delta]Vnfw[rn, 0.001]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotNFWGrayRed:"];
Print@plotNFWGrayRed;




Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, n\[Sigma]_]:= (*chi2Upper[rcn, n\[Sigma]] =*) NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]Vnfw[rn,rsn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];

chi2Lower[rsn_?NumberQ, n\[Sigma]_]:= chi2Lower[rsn, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]Vnfw[rn,rsn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing"-> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.01;
rnEnd=0.99;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

rsnUpper[2] = rsn /. NMinimize[{chi2Upper[rsn,2], rsn > 0}, {rsn, 0, 1}][[2]];
rsnUpper[1] = rsn /. NMinimize[{chi2Upper[rsn,1], rsn > 0}, {rsn, 0, 1}][[2]];
rsnLower[2] = rsn /. NMinimize[{chi2Lower[rsn,2], rsn > 0}, {rsn, 10, 1000}][[2]];
rsnLower[1] = rsn /. NMinimize[{chi2Lower[rsn,1], rsn > 0}, {rsn, 10, 1000}][[2]];

Echo[{rsnUpper[1], rsnLower[1]}, "rsn 1\[Sigma] bounds: "];
Echo[{rsnUpper[2], rsnLower[2]}, "rsn 2\[Sigma] bounds: "];

plotNFWGlobalBestFit = Show[
  {
    plotNFWGrayRed,
    Plot[
      {
        \[Delta]Vnfw[rn, rsnUpper @ 2],
        \[Delta]Vnfw[rn, rsnUpper @ 1],
        \[Delta]Vnfw[rn, rsnLower @ 2],
        \[Delta]Vnfw[rn, rsnLower @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotNFWGlobalBestFit:"];
Print@plotNFWGlobalBestFit;

Export["plotNFWGlobalBestFit.pdf", plotNFWGlobalBestFit];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwFixed[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwFixed[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  (Divide @@@ RmaxXrs)^-1;  (*IMPORTANT INTRODUCED LOG HERE*)
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, 0, 20, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, 0, 20},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{0, 20}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, 0, maxPDF}, {x, maxPDF, 20}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{rsnUpper @ nSigmas, 0}, { rsnUpper @ nSigmas, 20}},
    Line @ {{rsnLower @ nSigmas, 0}, {rsnLower @ nSigmas, 20}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 20}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 20}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{0, 15}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{rsnUpper@nSigmas, rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, 0, 20}, PlotRange -> All]}]
];

statusHistogramNfwFixed[1, 0, 100];

statusHistogramNfwFixed[2, 0, 100];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwFixed[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwGY[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  (Divide @@@ RmaxXrs)^-1;  (*IMPORTANT INTRODUCED LOG HERE*)
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, 0, 20, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, 0, 20},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{0, 20}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, 0, maxPDF}, {x, maxPDF, 20}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{rsnUpper @ nSigmas, 0}, { rsnUpper @ nSigmas, 20}},
    Line @ {{rsnLower @ nSigmas, 0}, {rsnLower @ nSigmas, 20}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 20}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 20}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{0, 15}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{rsnUpper@nSigmas, rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, 0, 20}, PlotRange -> All]}]
];

statusHistogramNfwFixed[1, 0, 100];

statusHistogramNfwFixed[2, 0, 100];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwFixed[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwFixed[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  Log10 @ ((Divide @@@ RmaxXrs)^-1);  (*IMPORTANT INTRODUCED LOG HERE*)
 
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, -1, 4, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, -1, 4},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{-1, 4}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, -1, maxPDF}, {x, maxPDF, 4}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{Log10 @ rsnUpper @ nSigmas, 0}, {Log10 @ rsnUpper @ nSigmas, 100}},
    Line @ {{Log10 @ rsnLower @ nSigmas, 0}, {Log10 @ rsnLower @ nSigmas, 100}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 100}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 100}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{-1, 4}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{Log10 @ rsnUpper@nSigmas, Log10 @ rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, -1, 4}, PlotRange -> All]}]
];

statusHistogramNfwFixed[1, -1, 4];

statusHistogramNfwFixed[2,-1, 4];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwGY[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwGY[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  Log10 @ ((Divide @@@ RmaxXrs)^-1);  (*IMPORTANT INTRODUCED LOG HERE*)
  histoOptions =   Sequence @@ {
    Frame -> True, 
    Axes -> False, 
    ChartStyle -> Directive[EdgeForm[GrayLevel[0.4]], GrayLevel @ 0.8],
    FrameStyle -> Directive[GrayLevel[0.4], 16],
    PlotRangeClipping -> True,
    FrameTicks -> {{LinTicks, StripTickLabels@LinTicks2}, {LinTicks, StripTickLabels@LinTicks2}}
  };
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, -1, 4, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, -1, 4},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{-1, 4}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, -1, maxPDF}, {x, maxPDF, 4}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{Log10 @ rsnUpper @ nSigmas, 0}, {Log10 @ rsnUpper @ nSigmas, 100}},
    Line @ {{Log10 @ rsnLower @ nSigmas, 0}, {Log10 @ rsnLower @ nSigmas, 100}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 100}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 100}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{-1, 4}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{Log10 @ rsnUpper@nSigmas, Log10 @ rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, -1, 4}, PlotRange -> All]}]
];

statusHistogramNfwGY[1, -1, 4];

statusHistogramNfwGY[2,-1, 4];


Clear[X, \[Rho], \[Alpha],\[Gamma],\[Beta]]
\[Alpha] = 2.94 - Log10[(10^(X + 2.33))^-1.08 + (10^(X + 2.33))^2.29];
\[Beta] = 4.23 + 1.34 X + 0.26 X^2;
\[Gamma] = - 0.06 + Log10[(10^(X + 2.56))^-0.68 + (10^(X+2.56))];
\[Rho]DC14[rn_, rsn_, \[Rho]s_, X_] = \[Rho]s/((rn/rsn)^\[Gamma] (1+ (rn/rsn)^\[Alpha])^((\[Beta]-\[Gamma])/\[Alpha]));


X100min = -410;
X100max = -130;
Xmin = X100min/100.;
Xmax = X100max/100.;

(*Clear[MDC14aux]; *) (*Uncomment this to recompute and export MDC14aux.*)
If[DownValues@MDC14aux === {}, 
  SetSharedFunction[MDC14aux];
  ParallelTable[
    MDC14aux[rn_, rsn_, \[Rho]s_, X100] = 4 \[Pi] Rmax^3 Integrate[
      \[Rho]DC14[rnprime, rsn, \[Rho]s, X100 / 100] rnprime^2, {rnprime, 0, rn}, 
      Assumptions -> {rn > 0, rsn > 0}
    ], 
    {X100, X100min, X100max, 1}
  ];
  DumpSave["../AuxiliaryData/MDC14aux.mx", MDC14aux]
];


Clear[MDC14, VVDC14, \[Delta]VDC14];

iRound[x_] = IntegerPart[Round[x, 0.01] 100];

MDC14[rn_, rsn_, \[Rho]s_, X_] := MDC14aux[rn, rsn, \[Rho]s, iRound[X]];

VVDC14[rn_, rsn_, \[Rho]s_, X_] := G/(rn Rmax) MDC14[rn, rsn, \[Rho]s, X] ;

\[Delta]VDC14[rn_, rsn_, X_] := \[Delta]VDC14[rn, rsn, X] = Simplify[
  VVDC14[rn, rsn, \[Rho]s, X]/VVDC14[1, rsn, \[Rho]s, X],
  Assumptions -> {0 <= rn <= 1,  rsn > 0, Rmax > 0}
];



\[Sigma]Silverman = 0.082; (*The vertical KDE "error". This value will not be crucial here, since it is constant.*)

Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, X_, n\[Sigma]_]:= chi2Upper[rsn, X, n\[Sigma]] =  NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]VDC14[rn, rsn, X])^2/ \[Sigma]Silverman^2 ,
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];

chi2Lower[rsn_?NumberQ, X_, n\[Sigma]_] := chi2Lower[rsn, X, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]VDC14[rn,rsn, X])^2/ \[Sigma]Silverman^2 , 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

ClearAll[rsnUpper, rsnLower];
rsnUpper[2] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnUpper[1] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[2] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[1] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];

{rsnUpperR[2], rsnUpperR[1], rsnLowerR[2], rsnLowerR[1]} = Parallelize[
  {rsnUpper[2], rsnUpper[1], rsnLower[2], rsnLower[1]}
];

Echo[{rsnUpperR[1], rsnLowerR[1]}, "{rsn, X} 1\[Sigma] bounds: "];
Echo[{rsnUpperR[2], rsnLowerR[2]}, "{rsn, X} 2\[Sigma] bounds: "];


\[Sigma]Silverman = 0.082; (*The vertical KDE "error". This value will not be crucial here, since it is constant.*)

Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, X_, n\[Sigma]_]:= chi2Upper[rsn, X, n\[Sigma]] =  NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]VDC14[rn, rsn, X])^2/ \[Sigma]Silverman^2 ,
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];

chi2Lower[rsn_?NumberQ, X_, n\[Sigma]_] := chi2Lower[rsn, X, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]VDC14[rn,rsn, X])^2/  \[Sigma]Silverman^2 , 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

ClearAll[rsnUpper, rsnLower];
rsnUpper[2] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnUpper[1] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[2] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[1] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];

{rsnUpperR[2], rsnUpperR[1], rsnLowerR[2], rsnLowerR[1]} = Parallelize[
  {rsnUpper[2], rsnUpper[1], rsnLower[2], rsnLower[1]}
];

Echo[{rsnUpperR[1], rsnLowerR[1]}, "{rsn, X} 1\[Sigma] bounds: "];
Echo[{rsnUpperR[2], rsnLowerR[2]}, "{rsn, X} 2\[Sigma] bounds: "];


plotDC14GlobalBestFit = Show[
  {
    plotBurkertGrayRed /. {Dashed -> Dashing[.01], Black -> Red},
    plotNFWGrayRed /. {Dashed-> DotDashed, Black -> Orange},
    Plot[
      {
        \[Delta]VDC14[rn, Sequence@@ rsnUpperR @ 2],
        \[Delta]VDC14[rn, Sequence@@ rsnUpperR @ 1],
        \[Delta]VDC14[rn, Sequence@@ rsnLowerR @ 2],
        \[Delta]VDC14[rn, Sequence@@ rsnLowerR @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotDC14GlobalBestFit:"];
Print@plotDC14GlobalBestFit;

Export["plotDC14GlobalBestFit.pdf", plotDC14GlobalBestFit];


\[Rho]nfw[rn_, rsn_, \[Rho]s_] = \[Rho]s/(rn/rsn (1+rn/rsn)^2);

Mnfw[rn_, rsn_, \[Rho]s_] = 4 \[Pi] Rmax^3  Integrate[\[Rho]nfw[rnprime, rsn, \[Rho]s] rnprime^2, {rnprime, 0, rn}, Assumptions-> {rn>0, rsn>0}];

MSaddnfw[rn_, rsn_, \[Rho]s_] = rn^2 \!\(
\*SubscriptBox[\(\[PartialD]\), \(rn\)]\(
\*SubscriptBox[\(\[PartialD]\), \(rn\)]Mnfw[rn, \ rsn, \ \[Rho]s]\)\); (* the effective additional mass*)

MSnfw[rn_, rsn_, \[Rho]s_, \[Gamma]_] = Mnfw[rn, rsn, \[Rho]s] + \[Gamma] MSaddnfw[rn, rsn, \[Rho]s]; (*The total effective halo mass*)

VVSnfw[rn_, rsn_, \[Rho]s_, \[Gamma]_] = G/Rmax MSnfw[rn, rsn, \[Rho]s, \[Gamma]] /rn;

\[Delta]VSnfw[rn_, rsn_, \[Gamma]_] = FullSimplify[
  VVSnfw[rn, rsn, \[Rho]s, \[Gamma]] / VVSnfw[1, rsn, \[Rho]s, \[Gamma]],
  Assumptions -> {0 < rn < 1, 0 < rsn < 1, 0 < Rmax}
];


\[Gamma]min = -0.5;
\[Gamma]max = 1; (*I could have used \[Gamma]max = 2, but it gets far away from the observational data*)

n\[Gamma] = (\[Gamma]max - \[Gamma]min)/0.05 + 1;

plotSNFWGrayRed = Show[
  {
    plotBackground[2.0],
    plotSigmaRegionsRAR,
    Plot[
      {
        Evaluate@Table[\[Delta]VSnfw[rn, 10, X], {X, \[Gamma]min, \[Gamma]max, 0.05}], 
        Evaluate@Table[\[Delta]VSnfw[rn, 0.1, X], {X, \[Gamma]min, \[Gamma]max, 0.05}],
        \[Delta]VSnfw[rn, 0.1, 0],
        \[Delta]VSnfw[rn, 10, 0]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {Sequence@@Table[{Opacity[0.5], Thickness[0.01], ColorData["Rainbow"][i/n\[Gamma]]}, {i, n\[Gamma]}], Sequence@@Table[{Opacity[0.5], Thickness[0.01], ColorData["Rainbow"][i/n\[Gamma]]}, {i, n\[Gamma]}], {Black}, {Black}}
    ]
  }
]


\[Sigma]Silverman = 0.082; (*The vertical KDE "error". This value will not be crucial here, since it is constant.*)

Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, \[Gamma]_, n\[Sigma]_]:= chi2Upper[rsn, \[Gamma], n\[Sigma]] =  NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]VSnfw[rn, rsn, \[Gamma]])^2/ \[Sigma]Silverman^2 ,
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];

chi2Lower[rsn_?NumberQ, \[Gamma]_, n\[Sigma]_] := chi2Lower[rsn, \[Gamma], n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]VSnfw[rn,rsn, \[Gamma]])^2/  \[Sigma]Silverman^2 , 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

ClearAll[rsnUpper, rsnLower];
rsnUpper[2] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Upper[rsn, \[Gamma], 2], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];
rsnUpper[1] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Upper[rsn, \[Gamma], 1], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];
rsnLower[2] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Lower[rsn, \[Gamma], 2], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];
rsnLower[1] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Lower[rsn, \[Gamma], 1], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];

{rsnUpperR[2], rsnUpperR[1], rsnLowerR[2], rsnLowerR[1]} = Parallelize[
  {rsnUpper[2], rsnUpper[1], rsnLower[2], rsnLower[1]}
];

Echo[{rsnUpperR[1], rsnLowerR[1]}, "{rsn, \[Gamma]} 1\[Sigma] bounds: "];
Echo[{rsnUpperR[2], rsnLowerR[2]}, "{rsn, \[Gamma]} 2\[Sigma] bounds: "];


plotSnfwGlobalBestFit = Show[
  {
    plotBurkertGrayRed /. {Dashed -> Dashing[.01], Black -> Red},
    plotNFWGrayRed /. {Dashed -> DotDashed, Black -> Orange},
    Plot[
      {
        \[Delta]VSnfw[rn, Sequence@@ rsnUpperR @ 2],
        \[Delta]VSnfw[rn, Sequence@@ rsnUpperR @ 1],
        \[Delta]VSnfw[rn, Sequence@@ rsnLowerR @ 2],
        \[Delta]VSnfw[rn, Sequence@@ rsnLowerR @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotSnfwGlobalBestFit:"];
Print@plotSnfwGlobalBestFit;

Export["plotSnfwGlobalBestFit.pdf", plotSnfwGlobalBestFit];


\[Gamma]best = -0.5;

plotSNFWglobalGammaGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]VSnfw[rn, 1000, \[Gamma]best], 
        \[Delta]VSnfw[rn, 0.001, \[Gamma]best]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotSNFWglobalGammaGrayRed:"];
Print@plotSNFWglobalGammaGrayRed;




(* SPECIFIC DEFINITIONS *)

rnStart = 0.01;
rnEnd=0.99;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

rsnUpper[2] = rsn /. NMinimize[{chi2Upper[rsn, \[Gamma]best, 2], rsn > 0}, {rsn, 0, 1}][[2]];
rsnUpper[1] = rsn /. NMinimize[{chi2Upper[rsn, \[Gamma]best, 1], rsn > 0}, {rsn, 0, 1}][[2]];
rsnLower[2] = rsn /. NMinimize[{chi2Lower[rsn, \[Gamma]best, 2], rsn > 0}, {rsn, 10, 1000}][[2]];
rsnLower[1] = rsn /. NMinimize[{chi2Lower[rsn, \[Gamma]best, 1], rsn > 0}, {rsn, 10, 1000}][[2]];

Echo[{rsnUpper[1], rsnLower[1]}, "rsn 1\[Sigma] bounds: "];
Echo[{rsnUpper[2], rsnLower[2]}, "rsn 2\[Sigma] bounds: "];

plotNFWGlobalGammaBestFit = Show[
  {
    plotSNFWglobalGammaGrayRed,
    Plot[
      {
        \[Delta]VSnfw[rn, rsnUpper @ 2, \[Gamma]best],
        \[Delta]VSnfw[rn, rsnUpper @ 1, \[Gamma]best],
        \[Delta]VSnfw[rn, rsnLower @ 2, \[Gamma]best],
        \[Delta]VSnfw[rn, rsnLower @ 1, \[Gamma]best]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotNFWGlobalGammaBestFit:"];
Print@plotNFWGlobalGammaBestFit;

Export["plotNFWGlobalGammaBestFit.pdf", plotNFWGlobalGammaBestFit];


\[Delta]vP2g[rn_, hn_, fh_, frho_]= (rn ( E^(-(rn/hn))+  frho  fh E^(- fh rn/hn)))/( E^(-(1/hn))+  frho fh  E^(- fh /hn));
\[Delta]v2Palatini[rn_, gal_] := \[Delta]vP2g[rn, list1hn[[gal]], list1fh[[gal]], list1frho[[gal]]];
Show[plotBackground[4.0],
  plotSigmaRegionsRARNoBulge,
  Plot[Evaluate[\[Delta]v2Palatini[rn, #] & /@ Range@122], {rn, 0, 1}, 
PlotRange -> All, 
PlotStyle-> Directive[Opacity[0.1],Blue, Thick]]
]


saveThisPlot = False;

Clear @ list2\[Delta]VVmodel;
list2\[Delta]VVmodel[gal_] := Table[{rn, \[Delta]v2Palatini[rn, gal]}, {rn, RandomReal[1, 350]}];
list2\[Delta]VVmodelAll = Flatten[DeleteCases[list2\[Delta]VVmodel /@ Range @ 122, {}], 1];

list2\[Delta]VVmodelAlllimit = Select[list2\[Delta]VVmodelAll, #[[2]] < 5 &]; (*Data points with \[Delta]v larger than 5 are not considered, too far. This is just an approximation*)

distPalatini = distributionSilverman[list2\[Delta]VVmodelAlllimit, 400]; (*Due to the large dispersion of data points, 400 InterpolationPoints are used*)
pdfValuenSigmaPalatini[n_?NumberQ] := FindHDPDFValues[distPalatini, nSigmaProbability[n]];
(*plotBluePalatini = plotBlue[list2\[Delta]VVmodelAll, list1LimitsSigmaPalatini, {{xmin, xmax - 0.01}, {-0.5, 2.5}}, PlotRange -> {{0, 0.99}, {-0.5, 2.5}}] *)

Clear[plotPalatiniSigma];
plotPalatiniSigma[n_] := plotPalatiniSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaPalatini[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distPalatini, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotPalatiniCurves = Plot[
  Evaluate[\[Delta]v2Palatini[rn, #] & /@ Range@122], 
  {rn, 0, 1}, 
  PlotRange -> All, 
  PlotStyle -> Directive[Opacity[0.1],
  Blue, 
  Thick]
];

plotPalatiniContours = Show[
  {plotPalatiniSigma[1], 
  plotPalatiniSigma[2]}
];
  
Show[
  plotBackground[4.0],
  plotSigmaRegionsRARNoBulge,
  plotPalatiniCurves,
  plotPalatiniContours
]

savePreviousPlot["plotdeltaVPalatini.pdf"]


DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];

EchoTiming[
{rI[1], rD[1]} = Parallelize[{
  regionIntersection[plotPalatiniSigma[1],1], 
  regionDifference[plotPalatiniSigma[1],1]
  }]
];

efficiencyNAV[1]


Clear[a0, \[CapitalDelta]VVmodel, VVmodel, \[Delta]VVmodel];

saveThisPlot = False; (*Change this to True to save it*)

v2MondRaw[R_, gal_] := R kpc aBar[R, gal]/(1 - E^-Sqrt[RealAbs[aBar[R, gal]]/a0]);

\[CapitalDelta]v2MondRaw[R_, gal_] := v2MondRaw[R, gal] - aBar[R, gal] R kpc ;

\[Delta]v2MondRaw[rn_, gal_] := If[gdR["Rad", gal]=={}, 
  {}, 
  \[CapitalDelta]v2MondRaw[rn rmax[gal], gal] / \[CapitalDelta]v2MondRaw[rmax[gal], gal]
];

Echo[a0 = 1, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  Plot[
    Evaluate[\[Delta]v2MondRaw[rn, #]& /@ Range@175], {rn,0,1}, 
    PlotStyle-> Directive[Opacity[0.1],Blue, Thick], PlotRange -> All
  ]
]

savePreviousPlot["plotdeltaVmonda01.pdf"];


saveThisPlot = False;

Echo[a0 = 1. 10^-15, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  Plot[
    Evaluate[\[Delta]v2MondRaw[rn, #]& /@ Range@175], {rn,0,1},  
    PlotStyle -> Directive[Opacity[0.1], Blue, Thick], PlotRange -> All
  ]
]

savePreviousPlot["plotdeltaVmonda015.pdf"];


saveThisPlot = False;

a0 = 1.2 10^-13;
Clear @ list2\[Delta]v2MondRaw;
list2\[Delta]v2MondRaw[gal_] := If[
  gdR["Rad", gal] == {},
  {},
  Table[{rn, \[Delta]v2MondRaw[rn, gal]}, {rn, RandomReal[1,70]}]
];
list2\[Delta]v2MondRawAll = Flatten[DeleteCases[list2\[Delta]v2MondRaw /@ Range @ 175, {}], 1];

distMondRaw = distributionSilverman @ list2\[Delta]v2MondRawAll;

pdfValuenSigmaMondRaw[n_?NumberQ] := FindHDPDFValues[distMondRaw, nSigmaProbability[n]];

plotMondRawSigma[n_] := plotMondRawSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaMondRaw[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distMondRaw, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotMondRawCurves = Plot[
  Evaluate[\[Delta]v2MondRaw[rn, #] & /@ Range@122], 
  {rn, 0, 1}, 
  PlotRange -> All, 
  PlotStyle -> Directive[Opacity[0.1],
  Blue, 
  Thick]
];

plotMondRawContours = Show[
  {plotMondRawSigma[1], 
  plotMondRawSigma[2]}
];
  
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  plotMondRawCurves,
  plotMondRawContours
]

savePreviousPlot["plotdeltaVmondPrincipal.pdf"];


DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];

EchoTiming[
{rI[1], rD[1], rI[2], rD[2]} = Parallelize[{
  regionIntersection[plotMondRawSigma[1],1], 
  regionDifference[plotMondRawSigma[1],1],
  regionIntersection[plotMondRawSigma[2],2],
  regionDifference[plotMondRawSigma[2],2]
  }]
];

efficiencyNAV[1]
efficiencyNAV[2]
efficiencyNAVtotal[]


Clear[a0];

a0Max = 1.;
a0Min = 1. 10^-15;
a0Std = 1.2 10^-13;

aBarExp[R_, gal_] :=  vBarExp[R, gal]^2/(R kpc);
v2MondExp[R_, gal_] := R kpc aBarExp[R, gal]/(1 - E^-Sqrt[aBarExp[R, gal]/a0]);
\[CapitalDelta]v2MondExp[R_, gal_] := v2MondExp[R, gal] - vBarExp[R, gal]^2;

\[Delta]v2MondExpAux[rn_, gal_] := \[CapitalDelta]v2MondExp[rn rmax122[gal], gal]/\[CapitalDelta]v2MondExp[rmax122[gal], gal];

Clear[table\[Delta]v2MondExp, a0];
table\[Delta]v2MondExp[a0_] = ParallelTable[{rn, \[Delta]v2MondExpAux[rn, gal]}, {gal, 122}, {rn, 0.01, 1, 0.01} ];



saveThisPlot = False; (*Change this to True to save it*)

Clear[\[Delta]v2MondExp];

(\[Delta]v2MondExpMax[rn_, #] = Interpolation[table\[Delta]v2MondExp[a0Max][[#]], Method -> "Spline"][rn])& /@ Range@122;
Echo[a0Max, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRARNoBulge,
  Plot[
    Evaluate[\[Delta]v2MondExpMax[rn, #]& /@ Range@122], {rn,0,1}, 
    PlotStyle-> Directive[Opacity[0.1],Blue, Thick], PlotRange -> All
  ]
]

savePreviousPlot["plotdeltaVmondExpa01.pdf"];


saveThisPlot = False;

(\[Delta]v2MondExpMin[rn_, #] = Interpolation[table\[Delta]v2MondExp[a0Min][[#]], Method -> "Spline"][rn])& /@ Range@122;
Echo[a0Min, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRARNoBulge,
  Plot[
    Evaluate[\[Delta]v2MondExpMin[rn, #]& /@ Range@122], {rn,0,1}, 
    PlotStyle-> Directive[Opacity[0.1],Blue, Thick], PlotRange -> All
  ]
]

savePreviousPlot["plotdeltaVmondExp015.pdf"];


saveThisPlot = False;

(\[Delta]v2MondExp[rn_, #] = Interpolation[table\[Delta]v2MondExp[a0Std][[#]], Method -> "Spline"][rn]) & /@ Range @ 122;

list2\[Delta]v2MondExp[gal_] := Table[{rn, \[Delta]v2MondExp[rn, gal]}, {rn, RandomReal[1, 70]}];

list2\[Delta]v2MondExpAll = Flatten[list2\[Delta]v2MondExp /@ Range @ 122, 1];

distMondExp = distributionSilverman @ list2\[Delta]v2MondExpAll;

pdfValuenSigmaMondExp[n_?NumberQ] := FindHDPDFValues[distMondExp, nSigmaProbability[n]];

plotMondExpSigma[n_] := plotMondExpSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaMondExp[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distMondExp, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotMondExpCurves = Plot[
  Evaluate[\[Delta]v2MondExp[rn, #] & /@ Range @ 122], 
  {rn, 0, 1}, 
  PlotStyle -> Directive[Opacity[0.1], Blue, Thick], 
  PlotRange -> All
];

plotMondExpContours = Show[{plotMondExpSigma[1], plotMondExpSigma[2]}];

Echo[a0Std, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRARNoBulge,
  plotMondExpCurves,
  plotMondExpContours
]

savePreviousPlot["plotdeltaVmondExpPrincipal.pdf"];



DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];

EchoTiming[
{rI[1], rD[1], rI[2], rD[2]} = Parallelize[{
  regionIntersection[plotMondExpSigma[1],1], 
  regionDifference[plotMondExpSigma[1],1],
  regionIntersection[plotMondExpSigma[2],2],
  regionDifference[plotMondExpSigma[2],2]
  }]
];

efficiencyNAV[1]
efficiencyNAV[2]
efficiencyNAVtotal[]


 Clear[phiExpDisk, phiExpGal, phiExpGal, \[CapitalDelta]VVRGGR, \[Delta]VVRGGR]


\[CapitalDelta]v2Rggr[R_, gal_] := - v2Infty vBarExp[R, gal]^2 / phiBarExp[R, gal];

\[Delta]v2RggrAux[rn_, gal_Integer] := \[CapitalDelta]v2Rggr[rn rmax122[gal], gal] / \[CapitalDelta]v2Rggr[rmax122[gal], gal];

table\[Delta]v2Rggr = ParallelTable[{rn, \[Delta]v2RggrAux[rn, gal]}, {gal, 122}, {rn, 0.01, 1, 0.01} ];

(\[Delta]v2Rggr[rn_, #] = Interpolation[table\[Delta]v2Rggr[[#]], Method -> "Spline"][rn]) & /@ Range @ 122;

(*
l1\[Delta]VVRGGR[rni_] = Block[
  {l2\[Delta]VVRGGRAux},
  l2\[Delta]VVRGGRAux[gali_] := Prepend[
    Table[{rni, \[Delta]VVRGGRAux[rni, gali]}, {rni, 0.05, 1, 0.05}], 
    {0,0}
  ];
  Table[
    Interpolation[l2\[Delta]VVRGGRAux[gali]][rni], 
  {gali, nG}
  ]
];

\[Delta]VVRGGR[rn_, gal_] :=  l1\[Delta]VVRGGR[rn][[gal]]*)


saveThisPlot = False; 

list2\[Delta]v2Rggr[gal_] := Table[{rn, \[Delta]v2Rggr[rn, gal]}, {rn, RandomReal[1, 70]}]; (*Picks random points along each model curve*)

list2\[Delta]v2RggrAll = Flatten[list2\[Delta]v2Rggr /@ Range @ 122, 1];

distRggr = distributionSilverman @ list2\[Delta]v2RggrAll;

pdfValuenSigmaRggr[n_?NumberQ] := FindHDPDFValues[distRggr, nSigmaProbability[n]];

plotRggrSigma[n_] := plotRggrSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaRggr[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distRggr, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotRggrCurves = Plot[
  Evaluate[\[Delta]v2Rggr[rn, #] & /@ Range @ 122], 
  {rn, 0, 1}, 
  PlotStyle -> Directive[Opacity[0.1], Blue, Thick], 
  PlotRange -> All
];

plotRggrContours = Show[{plotRggrSigma[1], plotRggrSigma[2]}];

Show[
  plotBackground[2],
  plotSigmaRegionsRARNoBulge,
  plotRggrCurves,
  plotRggrContours
]

savePreviousPlot["plotdeltaVRGGR.pdf"];


DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];

EchoTiming[
{rI[1], rD[1], rI[2], rD[2]} = Parallelize[{
  regionIntersection[plotRggrSigma[1],1], 
  regionDifference[plotRggrSigma[1],1],
  regionIntersection[plotRggrSigma[2],2],
  regionDifference[plotRggrSigma[2],2]
  }]
];

efficiencyNAV[1]
efficiencyNAV[2]
efficiencyNAVtotal[]


Clear[\[Alpha], \[Mu], \[Mu]MOG, \[Mu]MOGinfty, fgas, \[CapitalDelta]D0, \[Mu]MOGstd, \[Mu]MOGinfty];

D0std = 6.25 10^3; (*std = Standard value*)

Off[NIntegrate::precw];
diffAbs[r_, rprime_, \[Theta]_] = Sqrt[r^2 + rprime^2 - 2 r rprime Cos[\[Theta]]];

\[CapitalDelta]v2MOG[r_, \[Alpha]_, \[Mu]_, gal_, fgas_] :=  kpc^2 G0 \[Alpha] r NIntegrate[
  sigmaBarExpf[r, gal, fgas]/diffAbs[r, rprime, \[Theta]]^2 (1 - Exp[- \[Mu] diffAbs[r, rprime, \[Theta]]] ( 1 + \[Mu] diffAbs[r, rprime, \[Theta]])) rprime, 
  {\[Theta], -\[Pi], \[Pi]}, {rprime, 0, 1}, 
  Exclusions -> "Singularities", 
  WorkingPrecision -> 30, 
  PrecisionGoal -> 5, 
  AccuracyGoal -> Infinity
];

\[Delta]v2MOG[rn_, \[Mu]_, gal_, fgas_:1] := \[CapitalDelta]v2MOG[rn rmax122[gal], 1, \[Mu], gal, fgas]/ \[CapitalDelta]v2MOG[rmax122[gal], 1, \[Mu], gal, fgas]; (*\[Alpha] was used here to be 1, \[Delta]v2MOG is independ from \[Alpha]*)
\[Mu]MOG[gal_] := (D0std \[CapitalDelta]D0)/Sqrt[massExpBar[gal]];
\[Mu]MOG[gal_, rStarEnd_, rGasEnd_, fgas_] := (D0std \[CapitalDelta]D0)/Sqrt[massExpBar[gal, rStarEnd, rGasEnd, fgas]];
\[Mu]MOGstd[gal_] := \[Mu]MOG[gal, 4.5 hExpStar[gal], rmax122[gal], fgas];
\[Mu]MOGinfty[gal_] := (D0std \[CapitalDelta]D0)/Sqrt[massExpInftyBar[gal]];

Clear[table\[Delta]v2MOG];
table\[Delta]v2MOG[\[Mu]_, gal_] := Table[{rn, \[Delta]v2MOG[rn, \[Mu], gal, fgas]}, {rn, 0.01, 1, 0.0198} ]; (*0.198 for 50 steps per galaxy*)
table\[Delta]v2MOG[gal_] := Table[{rn, \[Delta]v2MOG[rn, \[Mu]MOG[gal], gal, fgas]}, {rn, 0.01, 1, 0.0198} ];
table\[Delta]v2MOGinfty[gal_] := Table[{rn, \[Delta]v2MOG[rn, \[Mu]MOGinfty[gal], gal, fgas]}, {rn, 0.01, 1, 0.0198} ];
table\[Delta]v2MOGstd[gal_] := Table[{rn, \[Delta]v2MOG[rn, \[Mu]MOGstd[gal], gal, fgas]}, {rn, 0.01, 1, 0.0198} ];



\[CapitalDelta]D0 = 10^-10;
fgas = 1.5;

CloseKernels[];
LaunchKernels[];
DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];
ParallelEvaluate[Off[NIntegrate::precw ]];
EchoTiming[
  table\[Delta]v2MOGstdResults =  ParallelTable[table\[Delta]v2MOGstd[gal], {gal, 122}];
]


Clear[plotMOGSigma];

list2\[Delta]v2MOG[gal_] := Table[{rn, \[Delta]v2MOGstd[rn, gal]}, {rn, RandomReal[1, 200]}]; (*Picks random points along each model curve*)

list2\[Delta]v2MOGAll = Select[
  Flatten[list2\[Delta]v2MOG /@ Range @ 122, 1], 
  #[[2]] < 5 &
]; (*Data points with \[Delta]v2 larger than 5 are not considered, too far. This is just an approximation*)

distMOG = distributionSilverman[list2\[Delta]v2MOGAll, 400]; (*Due to the large dispersion of data points, 400 InterpolationPoints are used*)

pdfValuenSigmaMOG[n_?NumberQ] := FindHDPDFValues[distMOG, nSigmaProbability[n]];

plotMOGSigma[n_] := plotMOGSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaMOG[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distMOG, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotMOGCurves = Plot[
  Evaluate[\[Delta]v2MOGstd[rn, #] & /@ Range @ 122], 
  {rn, 0, 1}, 
  PlotStyle -> Directive[Opacity[0.1], Blue, Thick], 
  PlotRange -> All
];

plotMOGContours = Show[{plotMOGSigma[1], plotMOGSigma[2]}];

Show[
  plotBackground[4],
  plotSigmaRegionsRARNoBulge,
  plotMOGCurves,
  plotMOGContours,
  Background-> White
]


(*DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];*)

EchoTiming[
{rI[1], rD[1]} = Parallelize[{
  regionIntersection[plotMOGSigma[1],1], 
  regionDifference[plotMOGSigma[1],1]
  }]
];

efficiencyNAV[1]


\[CapitalDelta]D0 = 1;
fgas = 1.15;

CloseKernels[];
LaunchKernels[];
DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];
ParallelEvaluate[Off[NIntegrate::precw ]];
EchoTiming[
table\[Delta]v2MOGstdResults =  ParallelTable[table\[Delta]v2MOGstd[gal], {gal, 122}]; ]


Clear[plotMOGSigma];

list2\[Delta]v2MOG[gal_] := Table[{rn, \[Delta]v2MOGstd[rn, gal]}, {rn, RandomReal[1, 200]}]; (*Picks random points along each model curve*)

list2\[Delta]v2MOGAll = Select[
  Flatten[list2\[Delta]v2MOG /@ Range @ 122, 1], 
  #[[2]] < 5 &
]; (*Data points with \[Delta]v2 larger than 5 are not considered, too far. This is just an approximation*)

distMOG = distributionSilverman[list2\[Delta]v2MOGAll, 400]; (*Due to the large dispersion of data points, 400 InterpolationPoints are used*)

pdfValuenSigmaMOG[n_?NumberQ] := FindHDPDFValues[distMOG, nSigmaProbability[n]];

plotMOGSigma[n_] := plotMOGSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaMOG[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distMOG, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotMOGCurves = Plot[
  Evaluate[\[Delta]v2MOGstd[rn, #] & /@ Range @ 122], 
  {rn, 0, 1}, 
  PlotStyle -> Directive[Opacity[0.1], Blue, Thick], 
  PlotRange -> All
];

plotMOGContours = Show[{plotMOGSigma[1], plotMOGSigma[2]}];

Show[
  plotBackground[4],
  plotSigmaRegionsRARNoBulge,
  plotMOGCurves,
  plotMOGContours,
  Background-> White
]


(*DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];*)

EchoTiming[
{rI[1], rD[1]} = Parallelize[{
  regionIntersection[plotMOGSigma[1],1], 
  regionDifference[plotMOGSigma[1],1]
  }]
];

efficiencyNAV[1]



