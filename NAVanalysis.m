(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



saveAllPlots = False; (*Change this to True to save ALL the plots that are generated in THIS notebook. It does not include NAVobservational plots. Saves for specific models are in their respective sections.*)
saveNAVobservationalPlots = False;
saveNAVobservationalTables = False;

pathBaseDirectory = NotebookDirectory[];
pathOutputDirectory = FileNameJoin[{pathBaseDirectory, "Output"}];
pathAuxDirectory = FileNameJoin[{pathBaseDirectory, "AuxiliaryData"}];

datasetExpVdiskNoBulge = Import[FileNameJoin[{pathOutputDirectory, "datasetExpVdiskNoBulge.m"}]]; (*Loads the exponential approximations for the stellar disk as a DataSet*)
datasetExpVgasNoBulge = Import[FileNameJoin[{pathOutputDirectory, "datasetExpVgasNoBulge.m"}]]; (*The same as above, but for the gas.*)

SetDirectory @ pathBaseDirectory;
Needs @ "NAVbaseCode`";
Get @ "NAVoptions.wl";
Print["Starting NAVobservational..."];
Get @ "NAVobservational.wl";
Get["MDC14aux.mx", Path -> pathAuxDirectory] // Quiet; (*If something goes wrong, this file will be generated*)

SetDirectory @ pathOutputDirectory;

(*
  FUNCTIONS DEFINITIONS THAT ARE BOTH USEFUL AND WORK AS SIMPLE EXAMPLES.
  
  These functions were created from the "galaxy data RAR" function (gdR). "RAR" since it is based on the 153 RAR galaxies.
  gdR returns "{}" whenever one considers a galaxy number that is in the original SPARC sample, but not in the RAR sample.
  
  phiExp and vExp come from Binney & Tremaine 2nd Ed., eq.(2.164a)
*)

Clear[rmax, rmin]; 
rmax[gal_] := Last[gdR["Rad", gal]]; (*gal here is the galaxy nunber for the complete sample with 175 galaxies *)
rmin[gal_] := First[gdR["Rad", gal]];
rmax122[gal_] := datasetExpVdiskNoBulge[gal, "rMax"]; (* same as rmax, but for the sample with 122 galaxies.*)

listVBar[gal_] := gdR[{"Rad", "Vbar"}, gal] // Prepend[#, {0, 0}] &; (*Includes YD contribution, as set in NAVbaseCode.*)
vBar[R_, gal_] := Interpolation[listVBar[gal], Method -> "Spline", InterpolationOrder -> 2][R]; (*Baryonic circular velocity*)

listABar[gal_] := {#1, squareSign[#2]/ (kpc #1)} & @@@ gdR[{"Rad", "Vbar"}, gal] // Prepend[#, {0, 0}] & ;
aBar[R_, gal_] := Interpolation[listABar[gal], Method -> "Spline", InterpolationOrder -> 2][R]; (*Baryonic acceleration*)

vExp[R_, logSigma0_, h_]= Block[{y}, 
  y = R/(2 h);
  kpc Sqrt[4 \[Pi] G0 10^logSigma0 h y^2 (BesselI[0,y] BesselK[0,y] - BesselI[1,y] BesselK[1,y])]
];
phiExp[R_, logSigma0_, h_] = Block[{y}, 
  y = R/(2 h);
  - 4 \[Pi] G0 10^logSigma0 R (BesselI[0,y] BesselK[1,y] - BesselI[1,y] BesselK[0,y])
];

hExpStar[gal_] := datasetExpVdiskNoBulge[gal, "h"];
logSigma0ExpStar[gal_] :=  Log10[YDcentral] + datasetExpVdiskNoBulge[gal, "logSigma0"]; (*The exponential results include use YDcentral=1, hence the correction here.*)
hExpGas[gal_] := datasetExpVgasNoBulge[gal, "hGas"];
logSigma0ExpGas[gal_] := datasetExpVgasNoBulge[gal, "logSigma0Gas"];

sigmaStarExp[R_, gal_] := 10^logSigma0ExpStar[gal] Exp[-R / hExpStar[gal]]; 
sigmaGasExp[R_, gal_] := 10^logSigma0ExpGas[gal] Exp[-R / hExpGas[gal]];
sigmaBarExp[R_, gal_] := sigmaStarExp[R, gal] + sigmaGasExp[R, gal];

vBarExp[R_, gal_] := Sqrt[
  vExp[R, logSigma0ExpStar[gal], hExpStar[gal]]^2+ vExp[R, logSigma0ExpGas[gal], hExpGas[gal]]^2
];
phiBarExp[R_, gal_] := phiExp[R, logSigma0ExpStar[gal], hExpStar[gal]] + phiExp[R, logSigma0ExpGas[gal], hExpGas[gal]];

massExpInftyStar[gal_] := 2 \[Pi] sigmaStarExp[0, gal] hExpStar[gal]^2 ; (*From Integrate[2 \[Pi] \[CapitalSigma]0 \[ExponentialE]^(-r/h) r, {r,0, \[Infinity]}]*)
massExpStar[gal_] := 2 \[Pi] sigmaStarExp[0, gal] hExpStar[gal] (hExpStar[gal] - E^(-(rmax122[gal]/hExpStar[gal])) (hExpStar[gal]+rmax122[gal]) ); (*From Integrate[2 \[Pi] \[CapitalSigma]0 \[ExponentialE]^(-r/h) r, {r,0, rmax}]*)
massExpInftyGas[gal_] := 2 \[Pi] sigmaGasExp[0, gal] hExpGas[gal]^2 ; (*From Integrate[2 \[Pi] \[CapitalSigma]0 \[ExponentialE]^(-r/h) r, {r,0, \[Infinity]}]*)
massExpGas[gal_] := 2 \[Pi] sigmaGasExp[0, gal] hExpGas[gal] (hExpGas[gal] - E^(-(rmax122[gal]/hExpGas[gal])) (hExpGas[gal]+rmax122[gal]) ); (*From Integrate[2 \[Pi] \[CapitalSigma]0 \[ExponentialE]^(-r/h) r, {r,0, rmax}]*)
massExpInftyBar[gal_] := massExpInftyGas[gal] + massExpInftyStar[gal];
massExpBar[gal_] := massExpGas[gal] + massExpStar[gal];

(*The definition below depends on rI and rD, which are defined, for each model, 
in their corresponding NAV efficiency section *)
efficiencyNAV[nSigma_] := (Area @ rI[nSigma] - Area @ rD[nSigma])/areaSigma @ plotObsSigma[nSigma];
efficiencyNAVtotal[] := Mean[{efficiencyNAV[1], efficiencyNAV[2]}];

savePreviousPlot[fileName_] := If[saveThisPlot || saveAllPlots, 
  Echo @ Export[ToString @ fileName, %]; saveThisPlot = False
];


\[Rho]brkt[rn_, rcn_, \[Rho]0_] = \[Rho]0/((1+rn/rcn)(1+rn^2/rcn^2));
Mbrkt[rn_, rcn_, \[Rho]0_] = 4 \[Pi] Rmax^3  Integrate[\[Rho]brkt[rnprime,rcn,\[Rho]0] rnprime^2,{rnprime,0,rn}, Assumptions-> {rn>0, rcn>0}];

VVbrkt[rn_, rcn_, \[Rho]0_, Rmax_] = (G / Rmax) * Mbrkt[rn, rcn, \[Rho]0] / rn;

\[Delta]Vbrkt[rn_, rcn_] = FullSimplify[
  VVbrkt[rn, rcn, \[Rho]0, Rmax] / VVbrkt[1, rcn, \[Rho]0, Rmax],
  Assumptions -> {0 < rn < 1, 0 < rcn < 1, 0 < Rmax}
];

plotBurkertGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]Vbrkt[rn, 1000], 
        \[Delta]Vbrkt[rn, 0.001]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotBurkertGrayRed:"];
Print@plotBurkertGrayRed;




Clear[chi2Upper, chi2Lower];
chi2Upper[rcn_?NumberQ, n\[Sigma]_]:= (*chi2Upper[rcn, n\[Sigma]] =*) NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]Vbrkt[rn,rcn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];

chi2Lower[rcn_?NumberQ, n\[Sigma]_]:= chi2Lower[rcn, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]Vbrkt[rn,rcn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing"-> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.01;
rnEnd=0.99;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

rcnUpper[2] = rcn /. NMinimize[{chi2Upper[rcn,2],rcn>0},{rcn,0,10}][[2]];
rcnUpper[1] = rcn /. NMinimize[{chi2Upper[rcn,1],rcn>0},{rcn,0,10}][[2]];
rcnLower[2] = rcn /. NMinimize[{chi2Lower[rcn,2],rcn>0},{rcn,0,10}][[2]];
rcnLower[1] = rcn /. NMinimize[{chi2Lower[rcn,1],rcn>0},{rcn,0,10}][[2]];

Echo[{rcnUpper[1], rcnLower[1]}, "rcn 1\[Sigma] bounds: "];
Echo[{rcnUpper[2], rcnLower[2]}, "rcn 2\[Sigma] bounds: "];

plotBurkertGlobalBestFit = Show[
  {
    plotBurkertGrayRed,
    Plot[
      {
        \[Delta]Vbrkt[rn, rcnUpper @ 2],
        \[Delta]Vbrkt[rn, rcnUpper @ 1],
        \[Delta]Vbrkt[rn, rcnLower @ 2],
        \[Delta]Vbrkt[rn, rcnLower @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotBurkertGlobalBestFit:"];
Print@plotBurkertGlobalBestFit;

Export["plotBurkertGlobalBestFit.pdf", plotBurkertGlobalBestFit];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rcnLowerLimit, rcnUpperLimit];

statusHistogram[nSigmas_, rcnLowerLimit_, rcnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rc[i_] := globalData[[i, colrc]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrcAll = Table[{Rmax @ i, rc @ i}, {i, 1, 175}];
  RmaxXrc = Delete[RmaxXrcAll, posExcluded];
  rcnDataAll =  (Divide @@@ RmaxXrcAll)^-1;
  rcnData =  (Divide @@@ RmaxXrc)^-1;
  
  rcnDataWithoutOutliers = Select[rcnData, rcnLowerLimit < # < rcnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rcnDataWithoutOutliers, 
    silvermanBw[rcnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist,x],
      {x, 0, 3, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist,x],
    {x, 0, 3},
    {y,0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{0., 3}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rcnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist,x]==pdfValuesForContours[[i]], #
    ] & /@ {{x,0,maxPDF}, {x,maxPDF,3}},
    FindRoot::brmp
  ];

  {rcnLow @ 1, rcnHigh @ 1} = x /. rcnRootsSigma[1];
  {rcnLow @ 2, rcnHigh @ 2} = x /. Quiet[rcnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{rcnUpper @ nSigmas, 0}, {rcnUpper @ nSigmas, 100}},
    Line @ {{rcnLower @ nSigmas, 0}, {rcnLower @ nSigmas, 100}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rcnLow @ nSigmas, 0}, {rcnLow @ nSigmas, 100}},
    Line @ {{rcnHigh @ nSigmas, 0}, {rcnHigh @ nSigmas, 100}}
  };

  rcnDistributionHistogram := Histogram[
    rcnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{0, 3}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rcnLow@nSigmas, rcnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{rcnUpper@nSigmas, rcnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rcnLowerLimit, rcnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rcnDistributionHistogram, nPlot[PDF[dist,x], {x,0,3}, PlotRange -> All]}]
];

statusHistogram[1, 0, 100];

statusHistogram[2,0,100];


\[Rho]nfw[rn_, rsn_, \[Rho]s_] = \[Rho]s/(rn/rsn (1+rn/rsn)^2);
Mnfw[rn_, rsn_, \[Rho]s_] = 4 \[Pi] Rmax^3  Integrate[\[Rho]nfw[rnprime, rsn, \[Rho]s] rnprime^2, {rnprime, 0, rn}, Assumptions-> {rn>0, rsn>0}];

VVnfw[rn_, rsn_, \[Rho]s_, Rmax_] = (G / Rmax) * Mnfw[rn, rsn, \[Rho]s] / rn;

\[Delta]Vnfw[rn_, rsn_] = FullSimplify[
  VVnfw[rn, rsn, \[Rho]s, Rmax] / VVnfw[1, rsn, \[Rho]s, Rmax],
  Assumptions -> {0 < rn < 1, 0 < rsn < 1, 0 < Rmax}
];


plotNFWGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]Vnfw[rn, 1000], 
        \[Delta]Vnfw[rn, 0.001]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotNFWGrayRed:"];
Print@plotNFWGrayRed;




Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, n\[Sigma]_]:= (*chi2Upper[rcn, n\[Sigma]] =*) NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]Vnfw[rn,rsn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];

chi2Lower[rsn_?NumberQ, n\[Sigma]_]:= chi2Lower[rsn, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]Vnfw[rn,rsn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing"-> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.01;
rnEnd=0.99;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

rsnUpper[2] = rsn /. NMinimize[{chi2Upper[rsn,2], rsn > 0}, {rsn, 0, 1}][[2]];
rsnUpper[1] = rsn /. NMinimize[{chi2Upper[rsn,1], rsn > 0}, {rsn, 0, 1}][[2]];
rsnLower[2] = rsn /. NMinimize[{chi2Lower[rsn,2], rsn > 0}, {rsn, 10, 1000}][[2]];
rsnLower[1] = rsn /. NMinimize[{chi2Lower[rsn,1], rsn > 0}, {rsn, 10, 1000}][[2]];

Echo[{rsnUpper[1], rsnLower[1]}, "rsn 1\[Sigma] bounds: "];
Echo[{rsnUpper[2], rsnLower[2]}, "rsn 2\[Sigma] bounds: "];

plotNFWGlobalBestFit = Show[
  {
    plotNFWGrayRed,
    Plot[
      {
        \[Delta]Vnfw[rn, rsnUpper @ 2],
        \[Delta]Vnfw[rn, rsnUpper @ 1],
        \[Delta]Vnfw[rn, rsnLower @ 2],
        \[Delta]Vnfw[rn, rsnLower @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotNFWGlobalBestFit:"];
Print@plotNFWGlobalBestFit;

Export["plotNFWGlobalBestFit.pdf", plotNFWGlobalBestFit];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwFixed[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwFixed[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  (Divide @@@ RmaxXrs)^-1;  (*IMPORTANT INTRODUCED LOG HERE*)
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, 0, 20, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, 0, 20},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{0, 20}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, 0, maxPDF}, {x, maxPDF, 20}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{rsnUpper @ nSigmas, 0}, { rsnUpper @ nSigmas, 20}},
    Line @ {{rsnLower @ nSigmas, 0}, {rsnLower @ nSigmas, 20}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 20}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 20}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{0, 15}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{rsnUpper@nSigmas, rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, 0, 20}, PlotRange -> All]}]
];

statusHistogramNfwFixed[1, 0, 100];

statusHistogramNfwFixed[2, 0, 100];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwFixed[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwGY[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  (Divide @@@ RmaxXrs)^-1;  (*IMPORTANT INTRODUCED LOG HERE*)
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, 0, 20, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, 0, 20},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{0, 20}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, 0, maxPDF}, {x, maxPDF, 20}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{rsnUpper @ nSigmas, 0}, { rsnUpper @ nSigmas, 20}},
    Line @ {{rsnLower @ nSigmas, 0}, {rsnLower @ nSigmas, 20}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 20}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 20}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{0, 15}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{rsnUpper@nSigmas, rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, 0, 20}, PlotRange -> All]}]
];

statusHistogramNfwFixed[1, 0, 100];

statusHistogramNfwFixed[2, 0, 100];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwFixed[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwFixed[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  Log10 @ ((Divide @@@ RmaxXrs)^-1);  (*IMPORTANT INTRODUCED LOG HERE*)
 
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, -1, 4, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, -1, 4},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{-1, 4}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, -1, maxPDF}, {x, maxPDF, 4}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{Log10 @ rsnUpper @ nSigmas, 0}, {Log10 @ rsnUpper @ nSigmas, 100}},
    Line @ {{Log10 @ rsnLower @ nSigmas, 0}, {Log10 @ rsnLower @ nSigmas, 100}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 100}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 100}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{-1, 4}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{Log10 @ rsnUpper@nSigmas, Log10 @ rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, -1, 4}, PlotRange -> All]}]
];

statusHistogramNfwFixed[1, -1, 4];

statusHistogramNfwFixed[2,-1, 4];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwGY[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwGY[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  Log10 @ ((Divide @@@ RmaxXrs)^-1);  (*IMPORTANT INTRODUCED LOG HERE*)
  histoOptions =   Sequence @@ {
    Frame -> True, 
    Axes -> False, 
    ChartStyle -> Directive[EdgeForm[GrayLevel[0.4]], GrayLevel @ 0.8],
    FrameStyle -> Directive[GrayLevel[0.4], 16],
    PlotRangeClipping -> True,
    FrameTicks -> {{LinTicks, StripTickLabels@LinTicks2}, {LinTicks, StripTickLabels@LinTicks2}}
  };
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, -1, 4, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, -1, 4},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{-1, 4}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, -1, maxPDF}, {x, maxPDF, 4}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{Log10 @ rsnUpper @ nSigmas, 0}, {Log10 @ rsnUpper @ nSigmas, 100}},
    Line @ {{Log10 @ rsnLower @ nSigmas, 0}, {Log10 @ rsnLower @ nSigmas, 100}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 100}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 100}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{-1, 4}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{Log10 @ rsnUpper@nSigmas, Log10 @ rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, -1, 4}, PlotRange -> All]}]
];

statusHistogramNfwGY[1, -1, 4];

statusHistogramNfwGY[2,-1, 4];


Clear[X, \[Rho], \[Alpha],\[Gamma],\[Beta]]
\[Alpha] = 2.94 - Log10[(10^(X + 2.33))^-1.08 + (10^(X + 2.33))^2.29];
\[Beta] = 4.23 + 1.34 X + 0.26 X^2;
\[Gamma] = - 0.06 + Log10[(10^(X + 2.56))^-0.68 + (10^(X+2.56))];
\[Rho]DC14[rn_, rsn_, \[Rho]s_, X_] = \[Rho]s/((rn/rsn)^\[Gamma] (1+ (rn/rsn)^\[Alpha])^((\[Beta]-\[Gamma])/\[Alpha]));


X100min = -410;
X100max = -130;
Xmin = X100min/100.;
Xmax = X100max/100.;

(*Clear[MDC14aux]; *) (*Uncomment this to recompute and export MDC14aux.*)
If[DownValues@MDC14aux === {}, 
  SetSharedFunction[MDC14aux];
  ParallelTable[
    MDC14aux[rn_, rsn_, \[Rho]s_, X100] = 4 \[Pi] Rmax^3 Integrate[
      \[Rho]DC14[rnprime, rsn, \[Rho]s, X100 / 100] rnprime^2, {rnprime, 0, rn}, 
      Assumptions -> {rn > 0, rsn > 0}
    ], 
    {X100, X100min, X100max, 1}
  ];
  DumpSave["../AuxiliaryData/MDC14aux.mx", MDC14aux]
];


Clear[MDC14, VVDC14, \[Delta]VDC14];

iRound[x_] = IntegerPart[Round[x, 0.01] 100];

MDC14[rn_, rsn_, \[Rho]s_, X_] := MDC14aux[rn, rsn, \[Rho]s, iRound[X]];

VVDC14[rn_, rsn_, \[Rho]s_, X_] := G/(rn Rmax) MDC14[rn, rsn, \[Rho]s, X] ;

\[Delta]VDC14[rn_, rsn_, X_] := \[Delta]VDC14[rn, rsn, X] = Simplify[
  VVDC14[rn, rsn, \[Rho]s, X]/VVDC14[1, rsn, \[Rho]s, X],
  Assumptions -> {0 <= rn <= 1,  rsn > 0, Rmax > 0}
];



\[Sigma]Silverman = 0.082; (*The vertical KDE "error". This value will not be crucial here, since it is constant.*)

Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, X_, n\[Sigma]_]:= chi2Upper[rsn, X, n\[Sigma]] =  NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]VDC14[rn, rsn, X])^2/ \[Sigma]Silverman^2 ,
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];

chi2Lower[rsn_?NumberQ, X_, n\[Sigma]_] := chi2Lower[rsn, X, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]VDC14[rn,rsn, X])^2/ \[Sigma]Silverman^2 , 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

ClearAll[rsnUpper, rsnLower];
rsnUpper[2] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnUpper[1] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[2] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[1] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];

{rsnUpperR[2], rsnUpperR[1], rsnLowerR[2], rsnLowerR[1]} = Parallelize[
  {rsnUpper[2], rsnUpper[1], rsnLower[2], rsnLower[1]}
];

Echo[{rsnUpperR[1], rsnLowerR[1]}, "{rsn, X} 1\[Sigma] bounds: "];
Echo[{rsnUpperR[2], rsnLowerR[2]}, "{rsn, X} 2\[Sigma] bounds: "];


\[Sigma]Silverman = 0.082; (*The vertical KDE "error". This value will not be crucial here, since it is constant.*)

Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, X_, n\[Sigma]_]:= chi2Upper[rsn, X, n\[Sigma]] =  NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]VDC14[rn, rsn, X])^2/ \[Sigma]Silverman^2 ,
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];

chi2Lower[rsn_?NumberQ, X_, n\[Sigma]_] := chi2Lower[rsn, X, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]VDC14[rn,rsn, X])^2/  \[Sigma]Silverman^2 , 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

ClearAll[rsnUpper, rsnLower];
rsnUpper[2] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnUpper[1] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[2] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[1] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];

{rsnUpperR[2], rsnUpperR[1], rsnLowerR[2], rsnLowerR[1]} = Parallelize[
  {rsnUpper[2], rsnUpper[1], rsnLower[2], rsnLower[1]}
];

Echo[{rsnUpperR[1], rsnLowerR[1]}, "{rsn, X} 1\[Sigma] bounds: "];
Echo[{rsnUpperR[2], rsnLowerR[2]}, "{rsn, X} 2\[Sigma] bounds: "];


plotDC14GlobalBestFit = Show[
  {
    plotBurkertGrayRed /. {Dashed -> Dashing[.01], Black -> Red},
    plotNFWGrayRed /. {Dashed-> DotDashed, Black -> Orange},
    Plot[
      {
        \[Delta]VDC14[rn, Sequence@@ rsnUpperR @ 2],
        \[Delta]VDC14[rn, Sequence@@ rsnUpperR @ 1],
        \[Delta]VDC14[rn, Sequence@@ rsnLowerR @ 2],
        \[Delta]VDC14[rn, Sequence@@ rsnLowerR @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotDC14GlobalBestFit:"];
Print@plotDC14GlobalBestFit;

Export["plotDC14GlobalBestFit.pdf", plotDC14GlobalBestFit];


\[Rho]nfw[rn_, rsn_, \[Rho]s_] = \[Rho]s/(rn/rsn (1+rn/rsn)^2);

Mnfw[rn_, rsn_, \[Rho]s_] = 4 \[Pi] Rmax^3  Integrate[\[Rho]nfw[rnprime, rsn, \[Rho]s] rnprime^2, {rnprime, 0, rn}, Assumptions-> {rn>0, rsn>0}];

MSaddnfw[rn_, rsn_, \[Rho]s_] = rn^2 \!\(
\*SubscriptBox[\(\[PartialD]\), \(rn\)]\(
\*SubscriptBox[\(\[PartialD]\), \(rn\)]Mnfw[rn, \ rsn, \ \[Rho]s]\)\); (* the effective additional mass*)

MSnfw[rn_, rsn_, \[Rho]s_, \[Gamma]_] = Mnfw[rn, rsn, \[Rho]s] + \[Gamma] MSaddnfw[rn, rsn, \[Rho]s]; (*The total effective halo mass*)

VVSnfw[rn_, rsn_, \[Rho]s_, \[Gamma]_] = G/Rmax MSnfw[rn, rsn, \[Rho]s, \[Gamma]] /rn;

\[Delta]VSnfw[rn_, rsn_, \[Gamma]_] = FullSimplify[
  VVSnfw[rn, rsn, \[Rho]s, \[Gamma]] / VVSnfw[1, rsn, \[Rho]s, \[Gamma]],
  Assumptions -> {0 < rn < 1, 0 < rsn < 1, 0 < Rmax}
];


\[Gamma]min = -0.5;
\[Gamma]max = 1; (*I could have used \[Gamma]max = 2, but it gets far away from the observational data*)

n\[Gamma] = (\[Gamma]max - \[Gamma]min)/0.05 + 1;

plotSNFWGrayRed = Show[
  {
    plotBackground[2.0],
    plotSigmaRegionsRAR,
    Plot[
      {
        Evaluate@Table[\[Delta]VSnfw[rn, 10, X], {X, \[Gamma]min, \[Gamma]max, 0.05}], 
        Evaluate@Table[\[Delta]VSnfw[rn, 0.1, X], {X, \[Gamma]min, \[Gamma]max, 0.05}],
        \[Delta]VSnfw[rn, 0.1, 0],
        \[Delta]VSnfw[rn, 10, 0]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {Sequence@@Table[{Opacity[0.5], Thickness[0.01], ColorData["Rainbow"][i/n\[Gamma]]}, {i, n\[Gamma]}], Sequence@@Table[{Opacity[0.5], Thickness[0.01], ColorData["Rainbow"][i/n\[Gamma]]}, {i, n\[Gamma]}], {Black}, {Black}}
    ]
  }
]


\[Sigma]Silverman = 0.082; (*The vertical KDE "error". This value will not be crucial here, since it is constant.*)

Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, \[Gamma]_, n\[Sigma]_]:= chi2Upper[rsn, \[Gamma], n\[Sigma]] =  NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]VSnfw[rn, rsn, \[Gamma]])^2/ \[Sigma]Silverman^2 ,
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];

chi2Lower[rsn_?NumberQ, \[Gamma]_, n\[Sigma]_] := chi2Lower[rsn, \[Gamma], n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]VSnfw[rn,rsn, \[Gamma]])^2/  \[Sigma]Silverman^2 , 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

ClearAll[rsnUpper, rsnLower];
rsnUpper[2] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Upper[rsn, \[Gamma], 2], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];
rsnUpper[1] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Upper[rsn, \[Gamma], 1], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];
rsnLower[2] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Lower[rsn, \[Gamma], 2], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];
rsnLower[1] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Lower[rsn, \[Gamma], 1], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];

{rsnUpperR[2], rsnUpperR[1], rsnLowerR[2], rsnLowerR[1]} = Parallelize[
  {rsnUpper[2], rsnUpper[1], rsnLower[2], rsnLower[1]}
];

Echo[{rsnUpperR[1], rsnLowerR[1]}, "{rsn, \[Gamma]} 1\[Sigma] bounds: "];
Echo[{rsnUpperR[2], rsnLowerR[2]}, "{rsn, \[Gamma]} 2\[Sigma] bounds: "];


plotSnfwGlobalBestFit = Show[
  {
    plotBurkertGrayRed /. {Dashed -> Dashing[.01], Black -> Red},
    plotNFWGrayRed /. {Dashed -> DotDashed, Black -> Orange},
    Plot[
      {
        \[Delta]VSnfw[rn, Sequence@@ rsnUpperR @ 2],
        \[Delta]VSnfw[rn, Sequence@@ rsnUpperR @ 1],
        \[Delta]VSnfw[rn, Sequence@@ rsnLowerR @ 2],
        \[Delta]VSnfw[rn, Sequence@@ rsnLowerR @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotSnfwGlobalBestFit:"];
Print@plotSnfwGlobalBestFit;

Export["plotSnfwGlobalBestFit.pdf", plotSnfwGlobalBestFit];


\[Gamma]best = -0.5;

plotSNFWglobalGammaGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]VSnfw[rn, 1000, \[Gamma]best], 
        \[Delta]VSnfw[rn, 0.001, \[Gamma]best]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotSNFWglobalGammaGrayRed:"];
Print@plotSNFWglobalGammaGrayRed;




(* SPECIFIC DEFINITIONS *)

rnStart = 0.01;
rnEnd=0.99;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

rsnUpper[2] = rsn /. NMinimize[{chi2Upper[rsn, \[Gamma]best, 2], rsn > 0}, {rsn, 0, 1}][[2]];
rsnUpper[1] = rsn /. NMinimize[{chi2Upper[rsn, \[Gamma]best, 1], rsn > 0}, {rsn, 0, 1}][[2]];
rsnLower[2] = rsn /. NMinimize[{chi2Lower[rsn, \[Gamma]best, 2], rsn > 0}, {rsn, 10, 1000}][[2]];
rsnLower[1] = rsn /. NMinimize[{chi2Lower[rsn, \[Gamma]best, 1], rsn > 0}, {rsn, 10, 1000}][[2]];

Echo[{rsnUpper[1], rsnLower[1]}, "rsn 1\[Sigma] bounds: "];
Echo[{rsnUpper[2], rsnLower[2]}, "rsn 2\[Sigma] bounds: "];

plotNFWGlobalGammaBestFit = Show[
  {
    plotSNFWglobalGammaGrayRed,
    Plot[
      {
        \[Delta]VSnfw[rn, rsnUpper @ 2, \[Gamma]best],
        \[Delta]VSnfw[rn, rsnUpper @ 1, \[Gamma]best],
        \[Delta]VSnfw[rn, rsnLower @ 2, \[Gamma]best],
        \[Delta]VSnfw[rn, rsnLower @ 1, \[Gamma]best]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotNFWGlobalGammaBestFit:"];
Print@plotNFWGlobalGammaBestFit;

Export["plotNFWGlobalGammaBestFit.pdf", plotNFWGlobalGammaBestFit];


\[Delta]vP2g[rn_, hn_, fh_, frho_]= (rn ( E^(-(rn/hn))+  frho  fh E^(- fh rn/hn)))/( E^(-(1/hn))+  frho fh  E^(- fh /hn));
\[Delta]v2Palatini[rn_, gal_] := \[Delta]vP2g[rn, list1hn[[gal]], list1fh[[gal]], list1frho[[gal]]];
Show[plotBackground[4.0],
  plotSigmaRegionsRARNoBulge,
  Plot[Evaluate[\[Delta]v2Palatini[rn, #] & /@ Range@122], {rn, 0, 1}, 
PlotRange -> All, 
PlotStyle-> Directive[Opacity[0.1],Blue, Thick]]
]


saveThisPlot = False;

Clear @ list2\[Delta]VVmodel;
list2\[Delta]VVmodel[gal_] := Table[{rn, \[Delta]v2Palatini[rn, gal]}, {rn, RandomReal[1, 350]}];
list2\[Delta]VVmodelAll = Flatten[DeleteCases[list2\[Delta]VVmodel /@ Range @ 122, {}], 1];

list2\[Delta]VVmodelAlllimit = Select[list2\[Delta]VVmodelAll, #[[2]] < 5 &]; (*Data points with \[Delta]v larger than 5 are not considered, too far. This is just an approximation*)

distPalatini = distributionSilverman[list2\[Delta]VVmodelAlllimit, 400]; (*Due to the large dispersion of data points, 400 InpoterpolationPoints are used*)
pdfValuenSigmaPalatini[n_?NumberQ] := FindHDPDFValues[distPalatini, nSigmaProbability[n]];
(*plotBluePalatini = plotBlue[list2\[Delta]VVmodelAll, list1LimitsSigmaPalatini, {{xmin, xmax - 0.01}, {-0.5, 2.5}}, PlotRange -> {{0, 0.99}, {-0.5, 2.5}}] *)

Clear[plotPalatiniSigma];
plotPalatiniSigma[n_] := plotPalatiniSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaPalatini[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distPalatini, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotPalatiniCurves = Plot[
  Evaluate[\[Delta]v2Palatini[rn, #] & /@ Range@122], 
  {rn, 0, 1}, 
  PlotRange -> All, 
  PlotStyle -> Directive[Opacity[0.1],
  Blue, 
  Thick]
];

plotPalatiniContours = Show[
  {plotPalatiniSigma[1], 
  plotPalatiniSigma[2]}
];
  
Show[
  plotBackground[4.0],
  plotSigmaRegionsRARNoBulge,
  plotPalatiniCurves,
  plotPalatiniContours
]

savePreviousPlot["plotdeltaVPalatini.pdf"]


DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];

EchoTiming[
{rI[1], rD[1]} = Parallelize[{
  regionIntersection[plotPalatiniSigma[1],1], 
  regionDifference[plotPalatiniSigma[1],1]
  }]
];

efficiencyNAV[1]


Clear[a0, \[CapitalDelta]VVmodel, VVmodel, \[Delta]VVmodel];

saveThisPlot = False; (*Change this to True to save it*)

v2MondRaw[R_, gal_] := R kpc aBar[R, gal]/(1 - E^-Sqrt[RealAbs[aBar[R, gal]]/a0]);

\[CapitalDelta]v2MondRaw[R_, gal_] := v2MondRaw[R, gal] - aBar[R, gal] R kpc ;

\[Delta]v2MondRaw[rn_, gal_] := If[gdR["Rad", gal]=={}, 
  {}, 
  \[CapitalDelta]v2MondRaw[rn rmax[gal], gal] / \[CapitalDelta]v2MondRaw[rmax[gal], gal]
];

Echo[a0 = 1, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  Plot[
    Evaluate[\[Delta]v2MondRaw[rn, #]& /@ Range@175], {rn,0,1}, 
    PlotStyle-> Directive[Opacity[0.1],Blue, Thick], PlotRange -> All
  ]
]

savePreviousPlot["plotdeltaVmonda01.pdf"];


saveThisPlot = False;

Echo[a0 = 1. 10^-15, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  Plot[
    Evaluate[\[Delta]v2MondRaw[rn, #]& /@ Range@175], {rn,0,1},  
    PlotStyle -> Directive[Opacity[0.1], Blue, Thick], PlotRange -> All
  ]
]

savePreviousPlot["plotdeltaVmonda015.pdf"];


saveThisPlot = False;

a0 = 1.2 10^-13;
Clear @ list2\[Delta]v2MondRaw;
list2\[Delta]v2MondRaw[gal_] := If[
  gdR["Rad", gal] == {},
  {},
  Table[{rn, \[Delta]v2MondRaw[rn, gal]}, {rn, RandomReal[1,70]}]
];
list2\[Delta]v2MondRawAll = Flatten[DeleteCases[list2\[Delta]v2MondRaw /@ Range @ 175, {}], 1];

distMondRaw = distributionSilverman @ list2\[Delta]v2MondRawAll;

pdfValuenSigmaMondRaw[n_?NumberQ] := FindHDPDFValues[distMondRaw, nSigmaProbability[n]];

plotMondRawSigma[n_] := plotMondRawSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaMondRaw[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distMondRaw, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotMondRawCurves = Plot[
  Evaluate[\[Delta]v2MondRaw[rn, #] & /@ Range@122], 
  {rn, 0, 1}, 
  PlotRange -> All, 
  PlotStyle -> Directive[Opacity[0.1],
  Blue, 
  Thick]
];

plotMondRawContours = Show[
  {plotMondRawSigma[1], 
  plotMondRawSigma[2]}
];
  
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  plotMondRawCurves,
  plotMondRawContours
]

savePreviousPlot["plotdeltaVmondPrincipal.pdf"];


DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];

EchoTiming[
{rI[1], rD[1], rI[2], rD[2]} = Parallelize[{
  regionIntersection[plotMondRawSigma[1],1], 
  regionDifference[plotMondRawSigma[1],1],
  regionIntersection[plotMondRawSigma[2],2],
  regionDifference[plotMondRawSigma[2],2]
  }]
];

efficiencyNAV[1]
efficiencyNAV[2]
efficiencyNAVtotal[]


Clear[a0];

a0Max = 1.;
a0Min = 1. 10^-15;
a0Std = 1.2 10^-13;

aBarExp[R_, gal_] :=  vBarExp[R, gal]^2/(R kpc);
v2MondExp[R_, gal_] := R kpc aBarExp[R, gal]/(1 - E^-Sqrt[aBarExp[R, gal]/a0]);
\[CapitalDelta]v2MondExp[R_, gal_] := v2MondExp[R, gal] - vBarExp[R, gal]^2;

\[Delta]v2MondExpAux[rn_, gal_] := \[CapitalDelta]v2MondExp[rn rmax122[gal], gal]/\[CapitalDelta]v2MondExp[rmax122[gal], gal];

Clear[table\[Delta]v2MondExp, a0];
table\[Delta]v2MondExp[a0_] = ParallelTable[{rn, \[Delta]v2MondExpAux[rn, gal]}, {gal, 122}, {rn, 0.01, 1, 0.01} ];



saveThisPlot = False; (*Change this to True to save it*)

Clear[\[Delta]v2MondExp];

(\[Delta]v2MondExpMax[rn_, #] = Interpolation[table\[Delta]v2MondExp[a0Max][[#]], Method -> "Spline"][rn])& /@ Range@122;
Echo[a0Max, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRARNoBulge,
  Plot[
    Evaluate[\[Delta]v2MondExpMax[rn, #]& /@ Range@122], {rn,0,1}, 
    PlotStyle-> Directive[Opacity[0.1],Blue, Thick], PlotRange -> All
  ]
]

savePreviousPlot["plotdeltaVmondExpa01.pdf"];


saveThisPlot = False;

(\[Delta]v2MondExpMin[rn_, #] = Interpolation[table\[Delta]v2MondExp[a0Min][[#]], Method -> "Spline"][rn])& /@ Range@122;
Echo[a0Min, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRARNoBulge,
  Plot[
    Evaluate[\[Delta]v2MondExpMin[rn, #]& /@ Range@122], {rn,0,1}, 
    PlotStyle-> Directive[Opacity[0.1],Blue, Thick], PlotRange -> All
  ]
]

savePreviousPlot["plotdeltaVmondExp015.pdf"];


saveThisPlot = False;

(\[Delta]v2MondExp[rn_, #] = Interpolation[table\[Delta]v2MondExp[a0Std][[#]], Method -> "Spline"][rn]) & /@ Range @ 122;

list2\[Delta]v2MondExp[gal_] := Table[{rn, \[Delta]v2MondExp[rn, gal]}, {rn, RandomReal[1, 70]}];

list2\[Delta]v2MondExpAll = Flatten[list2\[Delta]v2MondExp /@ Range @ 122, 1];

distMondExp = distributionSilverman @ list2\[Delta]v2MondExpAll;

pdfValuenSigmaMondExp[n_?NumberQ] := FindHDPDFValues[distMondExp, nSigmaProbability[n]];

plotMondExpSigma[n_] := plotMondExpSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaMondExp[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distMondExp, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotMondExpCurves = Plot[
  Evaluate[\[Delta]v2MondExp[rn, #] & /@ Range @ 122], 
  {rn, 0, 1}, 
  PlotStyle -> Directive[Opacity[0.1], Blue, Thick], 
  PlotRange -> All
];

plotMondExpContours = Show[{plotMondExpSigma[1], plotMondExpSigma[2]}];

Echo[a0Std, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRARNoBulge,
  plotMondExpCurves,
  plotMondExpContours
]

savePreviousPlot["plotdeltaVmondExpPrincipal.pdf"];



DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];

EchoTiming[
{rI[1], rD[1], rI[2], rD[2]} = Parallelize[{
  regionIntersection[plotMondExpSigma[1],1], 
  regionDifference[plotMondExpSigma[1],1],
  regionIntersection[plotMondExpSigma[2],2],
  regionDifference[plotMondExpSigma[2],2]
  }]
];

efficiencyNAV[1]
efficiencyNAV[2]
efficiencyNAVtotal[]


 Clear[phiExpDisk, phiExpGal, phiExpGal, \[CapitalDelta]VVRGGR, \[Delta]VVRGGR]


\[CapitalDelta]v2Rggr[R_, gal_] := - v2Infty vBarExp[R, gal]^2 / phiBarExp[R, gal];

\[Delta]v2RggrAux[rn_, gal_Integer] := \[CapitalDelta]v2Rggr[rn rmax122[gal], gal] / \[CapitalDelta]v2Rggr[rmax122[gal], gal];

table\[Delta]v2Rggr = ParallelTable[{rn, \[Delta]v2RggrAux[rn, gal]}, {gal, 122}, {rn, 0.01, 1, 0.01} ];

(\[Delta]v2Rggr[rn_, #] = Interpolation[table\[Delta]v2Rggr[[#]], Method -> "Spline"][rn]) & /@ Range @ 122;

(*
l1\[Delta]VVRGGR[rni_] = Block[
  {l2\[Delta]VVRGGRAux},
  l2\[Delta]VVRGGRAux[gali_] := Prepend[
    Table[{rni, \[Delta]VVRGGRAux[rni, gali]}, {rni, 0.05, 1, 0.05}], 
    {0,0}
  ];
  Table[
    Interpolation[l2\[Delta]VVRGGRAux[gali]][rni], 
  {gali, nG}
  ]
];

\[Delta]VVRGGR[rn_, gal_] :=  l1\[Delta]VVRGGR[rn][[gal]]*)


saveThisPlot = False; 

list2\[Delta]v2Rggr[gal_] := Table[{rn, \[Delta]v2Rggr[rn, gal]}, {rn, RandomReal[1, 70]}]; (*Picks random points along each model curve*)

list2\[Delta]v2RggrAll = Flatten[list2\[Delta]v2Rggr /@ Range @ 122, 1];

distRggr = distributionSilverman @ list2\[Delta]v2RggrAll;

pdfValuenSigmaRggr[n_?NumberQ] := FindHDPDFValues[distRggr, nSigmaProbability[n]];

plotRggrSigma[n_] := plotRggrSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaRggr[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distRggr, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotRggrCurves = Plot[
  Evaluate[\[Delta]v2Rggr[rn, #] & /@ Range @ 122], 
  {rn, 0, 1}, 
  PlotStyle -> Directive[Opacity[0.1], Blue, Thick], 
  PlotRange -> All
];

plotRggrContours = Show[{plotRggrSigma[1], plotRggrSigma[2]}];

Show[
  plotBackground[2],
  plotSigmaRegionsRARNoBulge,
  plotRggrCurves,
  plotRggrContours
]

savePreviousPlot["plotdeltaVRGGR.pdf"];


DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];

EchoTiming[
{rI[1], rD[1], rI[2], rD[2]} = Parallelize[{
  regionIntersection[plotRggrSigma[1],1], 
  regionDifference[plotRggrSigma[1],1],
  regionIntersection[plotRggrSigma[2],2],
  regionDifference[plotRggrSigma[2],2]
  }]
];

efficiencyNAV[1]
efficiencyNAV[2]
efficiencyNAVtotal[]


Clear[\[Alpha], \[Mu], \[Mu]MOG, \[Mu]MOGinfty];
Off[NIntegrate::precw];
diffAbs[r_, rprime_, \[Theta]_] = Sqrt[r^2 + rprime^2 - 2 r rprime Cos[\[Theta]]];
\[CapitalDelta]v2MOG[r_, \[Alpha]_, \[Mu]_, gal_] :=  kpc^2 G0 \[Alpha] r NIntegrate[
  sigmaBarExp[r, gal]/diffAbs[r, rprime, \[Theta]]^2 (1 - Exp[- \[Mu] diffAbs[r, rprime, \[Theta]]] ( 1 + \[Mu] diffAbs[r, rprime, \[Theta]])) rprime, 
  {\[Theta], -\[Pi], \[Pi]}, {rprime, 0, 1}, 
  Exclusions -> "Singularities", 
  WorkingPrecision -> 30, 
  PrecisionGoal -> 5, 
  AccuracyGoal -> Infinity
];

\[Delta]v2MOG[rn_, \[Mu]_, gal_] := \[CapitalDelta]v2MOG[rn rmax122[gal], 1, \[Mu], gal]/ \[CapitalDelta]v2MOG[rmax122[gal], 1, \[Mu], gal]; (*\[Alpha] was used here to be 1, \[Delta]v2MOG is independ from \[Alpha]*)
\[Mu]MOG[gal_] := \[Mu]MOG[gal] = (6.25 10^3)/Sqrt[massExpBar[gal]];
\[Mu]MOGinfty[gal_] := \[Mu]MOGinfty[gal] = (6.25 10^3)/Sqrt[massExpInftyBar[gal]];
\[Mu]MOG10[gal_] := \[Mu]MOG10[gal] = (6.25 10^4)/Sqrt[massExpBar[gal]];



Clear[table\[Delta]v2MOG];
table\[Delta]v2MOG[\[Mu]_, gal_] := Table[{rn, \[Delta]v2MOG[rn, \[Mu], gal]}, {rn, 0.01, 1, 0.0198} ]; (*0.198 for 50 steps per galaxy*)

table\[Delta]v2MOG[gal_] := Table[{rn, \[Delta]v2MOG[rn, \[Mu]MOG[gal], gal]}, {rn, 0.01, 1, 0.0198} ];
table\[Delta]v2MOGinfty[gal_] := Table[{rn, \[Delta]v2MOG[rn, \[Mu]MOGinfty[gal], gal]}, {rn, 0.01, 1, 0.0198} ];
table\[Delta]v2MOG10[gal_] := Table[{rn, \[Delta]v2MOG[rn, \[Mu]MOG10[gal], gal]}, {rn, 0.01, 1, 0.0198} ]



