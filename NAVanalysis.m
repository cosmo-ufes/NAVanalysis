(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



isBurkertWithGaussianPriors = True; (*Loads the Burkert data with Gaussian priors (True), or the fixed case (False)*)

SetDirectory @ FileNameJoin[{NotebookDirectory[], "Output"}];
datasetExpVdiskNoBulge = Import["datasetExpVdiskNoBulge.m"]; (*Loads the exponential approximations for the stellar disk as a DataSet*)
datasetExpVgasNoBulge = Import["datasetExpVgasNoBulge.m"]; (*The same as above, but for the gas.*)

SetDirectory @ NotebookDirectory[];
Needs @ "NAVbaseCode`";
Get @ "NAVoptions.wl";
Print["Starting NAVobservational..."];
Get @ "NAVobservational.wl";
Get["MDC14aux.mx", Path -> "AuxiliaryData"] // Quiet; (*If something goes wrong, this file will be generated*)

SetDirectory @ FileNameJoin[{NotebookDirectory[], "Output"}];

If[isBurkertWithGaussianPriors,
  exportBurkertIndividualResultsGaussian,
  (*else*)
  exportBurkertIndividualResultsFixed,
  (*if neither True or False*)
  Exit[]
];

(*
  FUNCTIONS DEFINITIONS THAT ARE BOTH USEFUL AND WORK AS SIMPLE EXAMPLES.
  These functions were created from the "galaxy data RAR" function (gdR). "RAR" since it is based on the 153 RAR galaxies.
  gdR returns "{}" whenever one considers a galaxy number that is in the original SPARC sample, but not in the RAR sample.
*)

Clear[rmax, rmin]; 
rmax[gal_] := Last[gdR["Rad", gal]]; (*gal here is the galaxy nunber for the complete sample with 175 galaxies *)
rmin[gal_] := First[gdR["Rad", gal]];

listVBar[gal_] := gdR[{"Rad", "Vbar"}, gal] // Prepend[#, {0, 0}] &;
vBar[R_, gal_] := Interpolation[listVBar[gal], Method -> "Spline", InterpolationOrder -> 2][R]; (*Baryonic circular velocity*)
listABar[gal_] := {#1, squareSign[#2]/ (kpc #1)} & @@@ gdR[{"Rad", "Vbar"}, gal] // Prepend[#, {0, 0}] & ;
aBar[R_, gal_] := Interpolation[listABar[gal], Method -> "Spline", InterpolationOrder -> 2][R]; (*Baryonic acceleration*)

(*The definition below depends on rI and rD, which are defined, for each model, 
in their corresponding NAV efficiency section *)
efficiencyNAV[nSigma_] := (Area @ rI[nSigma] - Area @ rD[nSigma])/areaSigma @ plotObsSigma[nSigma];
efficiencyNAVtotal[] := Mean[{efficiencyNAV[1], efficiencyNAV[2]}];



\[Rho]brkt[rn_, rcn_, \[Rho]0_] = \[Rho]0/((1+rn/rcn)(1+rn^2/rcn^2));
Mbrkt[rn_, rcn_, \[Rho]0_] = 4 \[Pi] Rmax^3  Integrate[\[Rho]brkt[rnprime,rcn,\[Rho]0] rnprime^2,{rnprime,0,rn}, Assumptions-> {rn>0, rcn>0}];

VVbrkt[rn_, rcn_, \[Rho]0_, Rmax_] = (G / Rmax) * Mbrkt[rn, rcn, \[Rho]0] / rn;

\[Delta]Vbrkt[rn_, rcn_] = FullSimplify[
  VVbrkt[rn, rcn, \[Rho]0, Rmax] / VVbrkt[1, rcn, \[Rho]0, Rmax],
  Assumptions -> {0 < rn < 1, 0 < rcn < 1, 0 < Rmax}
];

plotBurkertGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]Vbrkt[rn, 1000], 
        \[Delta]Vbrkt[rn, 0.001]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotBurkertGrayRed:"];
Print@plotBurkertGrayRed;




Clear[chi2Upper, chi2Lower];
chi2Upper[rcn_?NumberQ, n\[Sigma]_]:= (*chi2Upper[rcn, n\[Sigma]] =*) NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]Vbrkt[rn,rcn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];

chi2Lower[rcn_?NumberQ, n\[Sigma]_]:= chi2Lower[rcn, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]Vbrkt[rn,rcn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing"-> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.01;
rnEnd=0.99;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

rcnUpper[2] = rcn /. NMinimize[{chi2Upper[rcn,2],rcn>0},{rcn,0,10}][[2]];
rcnUpper[1] = rcn /. NMinimize[{chi2Upper[rcn,1],rcn>0},{rcn,0,10}][[2]];
rcnLower[2] = rcn /. NMinimize[{chi2Lower[rcn,2],rcn>0},{rcn,0,10}][[2]];
rcnLower[1] = rcn /. NMinimize[{chi2Lower[rcn,1],rcn>0},{rcn,0,10}][[2]];

Echo[{rcnUpper[1], rcnLower[1]}, "rcn 1\[Sigma] bounds: "];
Echo[{rcnUpper[2], rcnLower[2]}, "rcn 2\[Sigma] bounds: "];

plotBurkertGlobalBestFit = Show[
  {
    plotBurkertGrayRed,
    Plot[
      {
        \[Delta]Vbrkt[rn, rcnUpper @ 2],
        \[Delta]Vbrkt[rn, rcnUpper @ 1],
        \[Delta]Vbrkt[rn, rcnLower @ 2],
        \[Delta]Vbrkt[rn, rcnLower @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotBurkertGlobalBestFit:"];
Print@plotBurkertGlobalBestFit;

Export["plotBurkertGlobalBestFit.pdf", plotBurkertGlobalBestFit];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rcnLowerLimit, rcnUpperLimit];

statusHistogram[nSigmas_, rcnLowerLimit_, rcnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rc[i_] := globalData[[i, colrc]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrcAll = Table[{Rmax @ i, rc @ i}, {i, 1, 175}];
  RmaxXrc = Delete[RmaxXrcAll, posExcluded];
  rcnDataAll =  (Divide @@@ RmaxXrcAll)^-1;
  rcnData =  (Divide @@@ RmaxXrc)^-1;
  
  rcnDataWithoutOutliers = Select[rcnData, rcnLowerLimit < # < rcnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rcnDataWithoutOutliers, 
    silvermanBw[rcnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist,x],
      {x, 0, 3, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist,x],
    {x, 0, 3},
    {y,0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{0., 3}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rcnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist,x]==pdfValuesForContours[[i]], #
    ] & /@ {{x,0,maxPDF}, {x,maxPDF,3}},
    FindRoot::brmp
  ];

  {rcnLow @ 1, rcnHigh @ 1} = x /. rcnRootsSigma[1];
  {rcnLow @ 2, rcnHigh @ 2} = x /. Quiet[rcnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{rcnUpper @ nSigmas, 0}, {rcnUpper @ nSigmas, 100}},
    Line @ {{rcnLower @ nSigmas, 0}, {rcnLower @ nSigmas, 100}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rcnLow @ nSigmas, 0}, {rcnLow @ nSigmas, 100}},
    Line @ {{rcnHigh @ nSigmas, 0}, {rcnHigh @ nSigmas, 100}}
  };

  rcnDistributionHistogram := Histogram[
    rcnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{0, 3}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rcnLow@nSigmas, rcnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{rcnUpper@nSigmas, rcnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rcnLowerLimit, rcnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rcnDistributionHistogram, nPlot[PDF[dist,x], {x,0,3}, PlotRange -> All]}]
];

statusHistogram[1, 0, 100];

statusHistogram[2,0,100];


\[Rho]nfw[rn_, rsn_, \[Rho]s_] = \[Rho]s/(rn/rsn (1+rn/rsn)^2);
Mnfw[rn_, rsn_, \[Rho]s_] = 4 \[Pi] Rmax^3  Integrate[\[Rho]nfw[rnprime, rsn, \[Rho]s] rnprime^2, {rnprime, 0, rn}, Assumptions-> {rn>0, rsn>0}];

VVnfw[rn_, rsn_, \[Rho]s_, Rmax_] = (G / Rmax) * Mnfw[rn, rsn, \[Rho]s] / rn;

\[Delta]Vnfw[rn_, rsn_] = FullSimplify[
  VVnfw[rn, rsn, \[Rho]s, Rmax] / VVnfw[1, rsn, \[Rho]s, Rmax],
  Assumptions -> {0 < rn < 1, 0 < rsn < 1, 0 < Rmax}
];


plotNFWGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]Vnfw[rn, 1000], 
        \[Delta]Vnfw[rn, 0.001]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotNFWGrayRed:"];
Print@plotNFWGrayRed;




Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, n\[Sigma]_]:= (*chi2Upper[rcn, n\[Sigma]] =*) NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]Vnfw[rn,rsn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];

chi2Lower[rsn_?NumberQ, n\[Sigma]_]:= chi2Lower[rsn, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]Vnfw[rn,rsn])^2, 
  {rn,rnStart,rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing"-> 0},
  WorkingPrecision->10, 
  PrecisionGoal->3, 
  AccuracyGoal->Infinity, 
  MaxRecursion->10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.01;
rnEnd=0.99;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

rsnUpper[2] = rsn /. NMinimize[{chi2Upper[rsn,2], rsn > 0}, {rsn, 0, 1}][[2]];
rsnUpper[1] = rsn /. NMinimize[{chi2Upper[rsn,1], rsn > 0}, {rsn, 0, 1}][[2]];
rsnLower[2] = rsn /. NMinimize[{chi2Lower[rsn,2], rsn > 0}, {rsn, 10, 1000}][[2]];
rsnLower[1] = rsn /. NMinimize[{chi2Lower[rsn,1], rsn > 0}, {rsn, 10, 1000}][[2]];

Echo[{rsnUpper[1], rsnLower[1]}, "rsn 1\[Sigma] bounds: "];
Echo[{rsnUpper[2], rsnLower[2]}, "rsn 2\[Sigma] bounds: "];

plotNFWGlobalBestFit = Show[
  {
    plotNFWGrayRed,
    Plot[
      {
        \[Delta]Vnfw[rn, rsnUpper @ 2],
        \[Delta]Vnfw[rn, rsnUpper @ 1],
        \[Delta]Vnfw[rn, rsnLower @ 2],
        \[Delta]Vnfw[rn, rsnLower @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotNFWGlobalBestFit:"];
Print@plotNFWGlobalBestFit;

Export["plotNFWGlobalBestFit.pdf", plotNFWGlobalBestFit];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwFixed[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwFixed[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  (Divide @@@ RmaxXrs)^-1;  (*IMPORTANT INTRODUCED LOG HERE*)
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, 0, 20, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, 0, 20},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{0, 20}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, 0, maxPDF}, {x, maxPDF, 20}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{rsnUpper @ nSigmas, 0}, { rsnUpper @ nSigmas, 20}},
    Line @ {{rsnLower @ nSigmas, 0}, {rsnLower @ nSigmas, 20}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 20}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 20}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{0, 15}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{rsnUpper@nSigmas, rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, 0, 20}, PlotRange -> All]}]
];

statusHistogramNfwFixed[1, 0, 100];

statusHistogramNfwFixed[2, 0, 100];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwFixed[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwGY[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  (Divide @@@ RmaxXrs)^-1;  (*IMPORTANT INTRODUCED LOG HERE*)
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, 0, 20, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, 0, 20},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{0, 20}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, 0, maxPDF}, {x, maxPDF, 20}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{rsnUpper @ nSigmas, 0}, { rsnUpper @ nSigmas, 20}},
    Line @ {{rsnLower @ nSigmas, 0}, {rsnLower @ nSigmas, 20}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 20}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 20}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{0, 15}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{rsnUpper@nSigmas, rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, 0, 20}, PlotRange -> All]}]
];

statusHistogramNfwFixed[1, 0, 100];

statusHistogramNfwFixed[2, 0, 100];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwFixed[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwFixed[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  Log10 @ ((Divide @@@ RmaxXrs)^-1);  (*IMPORTANT INTRODUCED LOG HERE*)
 
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, -1, 4, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, -1, 4},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{-1, 4}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, -1, maxPDF}, {x, maxPDF, 4}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{Log10 @ rsnUpper @ nSigmas, 0}, {Log10 @ rsnUpper @ nSigmas, 100}},
    Line @ {{Log10 @ rsnLower @ nSigmas, 0}, {Log10 @ rsnLower @ nSigmas, 100}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 100}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 100}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{-1, 4}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{Log10 @ rsnUpper@nSigmas, Log10 @ rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, -1, 4}, PlotRange -> All]}]
];

statusHistogramNfwFixed[1, -1, 4];

statusHistogramNfwFixed[2,-1, 4];


(*rcn values outside the upper and lower limits are not considered*)
(*The upper limit is important to eliminate those cases that are essentially infinity,
these also pose technical difficulties for the kernel density estimation.
The lower limit may be important since we have droppend all data with rn < 0.2,
There are galaxies that use the DM profile to do a quick rise of the rotation curve.*)

Clear[statusHistogram, nSigmas, rsnLowerLimit, rsnUpperLimit];

colrs = colrc; (*then col number of rc is the same of rs*)

statusHistogramNfwGY[nSigmas_, rsnLowerLimit_, rsnUpperLimit_]:= Block[{},
  Rmax[i_] := Last @ gd[Rad, i];
  rs[i_] := globalDataNfwGY[[i, colrs]] ;
  posExcluded = Position[Table[galdataRAR @ n, {n, 1, 175}], {}];
  RmaxXrsAll = Table[{Rmax @ i, rs @ i}, {i, 1, 175}];
  RmaxXrs = Delete[RmaxXrsAll, posExcluded];
  rsnDataAll =  (Divide @@@ RmaxXrsAll)^-1;
  rsnData =  Log10 @ ((Divide @@@ RmaxXrs)^-1);  (*IMPORTANT INTRODUCED LOG HERE*)
  histoOptions =   Sequence @@ {
    Frame -> True, 
    Axes -> False, 
    ChartStyle -> Directive[EdgeForm[GrayLevel[0.4]], GrayLevel @ 0.8],
    FrameStyle -> Directive[GrayLevel[0.4], 16],
    PlotRangeClipping -> True,
    FrameTicks -> {{LinTicks, StripTickLabels@LinTicks2}, {LinTicks, StripTickLabels@LinTicks2}}
  };
  
  rsnDataWithoutOutliers = Select[rsnData, rsnLowerLimit < # < rsnUpperLimit &]; 
  dist = SmoothKernelDistribution[
    rsnDataWithoutOutliers, 
    silvermanBw[rsnDataWithoutOutliers], 
    MaxExtraBandwidths -> 0,
    InterpolationPoints -> 10^4
  ];

  pdfValuesForContours = Block[
    {
      positionAtCdf, oneSigmaProbability, twoSigmaProbability, positionsAtPdf, pdfList,
      pdfSortList, cdfSortList
    },
    oneSigmaProbability = NProbability[Less[-1, x, 1], Distributed[x, NormalDistribution[]]];
    twoSigmaProbability = NProbability[Less[-2, x, 2], Distributed[x, NormalDistribution[]]];
    pdfList = Table[
      PDF[dist, x],
      {x, -1, 4, 0.01}
    ];
    pdfSortList = Reverse @ Sort @ Flatten @ pdfList;
    cdfSortList = Accumulate[pdfSortList] / Total[pdfSortList] ;
    positionAtCdf[probability_] := FirstPosition[cdfSortList, p_ /; GreaterEqual[p, probability]];
    positionsAtPdf = Flatten @ Map[positionAtCdf, {oneSigmaProbability, twoSigmaProbability}];
    pdfSortList[[positionsAtPdf]]
  ];

  sigmaContoursPlot = ContourPlot[
    PDF[dist, x],
    {x, -1, 4},
    {y, 0, 2},
    Contours -> pdfValuesForContours, 
    PlotRange -> {{-1, 4}, All}
  ];

  sigmaContoursList = Cases[
    Normal @ FullForm @ First @ sigmaContoursPlot,
    Line[pts_] :> pts,
    Infinity
  ];

  maxPDF = x /. Last @ Maximize[PDF[dist, x], x];

  rsnRootsSigma[i_] := Quiet[
    FindRoot[
      PDF[dist, x] == pdfValuesForContours[[i]], #
    ] & /@ {{x, -1, maxPDF}, {x, maxPDF, 4}},
    FindRoot::brmp
  ];

  {rsnLow @ 1, rsnHigh @ 1} = x /. rsnRootsSigma[1];
  {rsnLow @ 2, rsnHigh @ 2} = x /. Quiet[rsnRootsSigma[2], FindRoot::brmp];

  lines = {
    Dashed, 
    Thickness @ 0.004, 
    Line @ {{Log10 @ rsnUpper @ nSigmas, 0}, {Log10 @ rsnUpper @ nSigmas, 100}},
    Line @ {{Log10 @ rsnLower @ nSigmas, 0}, {Log10 @ rsnLower @ nSigmas, 100}}
  };

  lines2= {
    Red,
    DotDashed, 
    Thickness @ 0.004, 
    Line @ {{rsnLow @ nSigmas, 0}, {rsnLow @ nSigmas, 100}},
    Line @ {{rsnHigh @ nSigmas, 0}, {rsnHigh @ nSigmas, 100}}
  };

  rsnDistributionHistogram := Histogram[
    rsnDataWithoutOutliers,
    {0.1}, 
    "PDF", 
    PlotRange -> {{-1, 4}, All},
    Frame -> True, 
    Axes -> False, 
    Epilog -> {lines, lines2}, 
    histoOptions
  ];

  Echo[ToString@nSigmas <>"\[Sigma] limits from individual fits:" <> ToString@{rsnLow@nSigmas, rsnHigh@nSigmas}];
  Echo[ToString@nSigmas <>"\[Sigma] limits from NAV method:" <> ToString@{Log10 @ rsnUpper@nSigmas, Log10 @ rsnLower@nSigmas}];
  Echo["Lower and upper rcn limits used for the individual Burkert fits: " <> ToString[{rsnLowerLimit, rsnUpperLimit}]];
  Echo["rcnDistributionHistogram for "<> ToString@nSigmas <>"\[Sigma]:"];
  Print@Show[{rsnDistributionHistogram, nPlot[PDF[dist, x], {x, -1, 4}, PlotRange -> All]}]
];

statusHistogramNfwGY[1, -1, 4];

statusHistogramNfwGY[2,-1, 4];


Clear[X, \[Rho], \[Alpha],\[Gamma],\[Beta]]
\[Alpha] = 2.94 - Log10[(10^(X + 2.33))^-1.08 + (10^(X + 2.33))^2.29];
\[Beta] = 4.23 + 1.34 X + 0.26 X^2;
\[Gamma] = - 0.06 + Log10[(10^(X + 2.56))^-0.68 + (10^(X+2.56))];
\[Rho]DC14[rn_, rsn_, \[Rho]s_, X_] = \[Rho]s/((rn/rsn)^\[Gamma] (1+ (rn/rsn)^\[Alpha])^((\[Beta]-\[Gamma])/\[Alpha]));


X100min = -410;
X100max = -130;
Xmin = X100min/100.;
Xmax = X100max/100.;

(*Clear[MDC14aux]; *) (*Uncomment this to recompute and export MDC14aux.*)
If[DownValues@MDC14aux === {}, 
  SetSharedFunction[MDC14aux];
  ParallelTable[
    MDC14aux[rn_, rsn_, \[Rho]s_, X100] = 4 \[Pi] Rmax^3 Integrate[
      \[Rho]DC14[rnprime, rsn, \[Rho]s, X100 / 100] rnprime^2, {rnprime, 0, rn}, 
      Assumptions -> {rn > 0, rsn > 0}
    ], 
    {X100, X100min, X100max, 1}
  ];
  DumpSave["../AuxiliaryData/MDC14aux.mx", MDC14aux]
];


Clear[MDC14, VVDC14, \[Delta]VDC14];

iRound[x_] = IntegerPart[Round[x, 0.01] 100];

MDC14[rn_, rsn_, \[Rho]s_, X_] := MDC14aux[rn, rsn, \[Rho]s, iRound[X]];

VVDC14[rn_, rsn_, \[Rho]s_, X_] := G/(rn Rmax) MDC14[rn, rsn, \[Rho]s, X] ;

\[Delta]VDC14[rn_, rsn_, X_] := \[Delta]VDC14[rn, rsn, X] = Simplify[
  VVDC14[rn, rsn, \[Rho]s, X]/VVDC14[1, rsn, \[Rho]s, X],
  Assumptions -> {0 <= rn <= 1,  rsn > 0, Rmax > 0}
];



\[Sigma]Silverman = 0.082; (*The vertical KDE "error". This value will not be crucial here, since it is constant.*)

Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, X_, n\[Sigma]_]:= chi2Upper[rsn, X, n\[Sigma]] =  NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]VDC14[rn, rsn, X])^2/ \[Sigma]Silverman^2 ,
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];

chi2Lower[rsn_?NumberQ, X_, n\[Sigma]_] := chi2Lower[rsn, X, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]VDC14[rn,rsn, X])^2/ \[Sigma]Silverman^2 , 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

ClearAll[rsnUpper, rsnLower];
rsnUpper[2] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnUpper[1] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[2] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[1] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];

{rsnUpperR[2], rsnUpperR[1], rsnLowerR[2], rsnLowerR[1]} = Parallelize[
  {rsnUpper[2], rsnUpper[1], rsnLower[2], rsnLower[1]}
];

Echo[{rsnUpperR[1], rsnLowerR[1]}, "{rsn, X} 1\[Sigma] bounds: "];
Echo[{rsnUpperR[2], rsnLowerR[2]}, "{rsn, X} 2\[Sigma] bounds: "];


\[Sigma]Silverman = 0.082; (*The vertical KDE "error". This value will not be crucial here, since it is constant.*)

Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, X_, n\[Sigma]_]:= chi2Upper[rsn, X, n\[Sigma]] =  NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]VDC14[rn, rsn, X])^2/ \[Sigma]Silverman^2 ,
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];

chi2Lower[rsn_?NumberQ, X_, n\[Sigma]_] := chi2Lower[rsn, X, n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]VDC14[rn,rsn, X])^2/  \[Sigma]Silverman^2 , 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

ClearAll[rsnUpper, rsnLower];
rsnUpper[2] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnUpper[1] :=  {rsn, X} /. NMinimize[{chi2Upper[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[2] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 2], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];
rsnLower[1] :=  {rsn, X} /. NMinimize[{chi2Lower[rsn, X, 1], 50>rsn>0.1, Xmin < X < Xmax}, {rsn, X}][[2]];

{rsnUpperR[2], rsnUpperR[1], rsnLowerR[2], rsnLowerR[1]} = Parallelize[
  {rsnUpper[2], rsnUpper[1], rsnLower[2], rsnLower[1]}
];

Echo[{rsnUpperR[1], rsnLowerR[1]}, "{rsn, X} 1\[Sigma] bounds: "];
Echo[{rsnUpperR[2], rsnLowerR[2]}, "{rsn, X} 2\[Sigma] bounds: "];


plotDC14GlobalBestFit = Show[
  {
    plotBurkertGrayRed /. {Dashed -> Dashing[.01], Black -> Red},
    plotNFWGrayRed /. {Dashed-> DotDashed, Black -> Orange},
    Plot[
      {
        \[Delta]VDC14[rn, Sequence@@ rsnUpperR @ 2],
        \[Delta]VDC14[rn, Sequence@@ rsnUpperR @ 1],
        \[Delta]VDC14[rn, Sequence@@ rsnLowerR @ 2],
        \[Delta]VDC14[rn, Sequence@@ rsnLowerR @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotDC14GlobalBestFit:"];
Print@plotDC14GlobalBestFit;

Export["plotDC14GlobalBestFit.pdf", plotDC14GlobalBestFit];


\[Rho]nfw[rn_, rsn_, \[Rho]s_] = \[Rho]s/(rn/rsn (1+rn/rsn)^2);

Mnfw[rn_, rsn_, \[Rho]s_] = 4 \[Pi] Rmax^3  Integrate[\[Rho]nfw[rnprime, rsn, \[Rho]s] rnprime^2, {rnprime, 0, rn}, Assumptions-> {rn>0, rsn>0}];

MSaddnfw[rn_, rsn_, \[Rho]s_] = rn^2 \!\(
\*SubscriptBox[\(\[PartialD]\), \(rn\)]\(
\*SubscriptBox[\(\[PartialD]\), \(rn\)]Mnfw[rn, \ rsn, \ \[Rho]s]\)\); (* the effective additional mass*)

MSnfw[rn_, rsn_, \[Rho]s_, \[Gamma]_] = Mnfw[rn, rsn, \[Rho]s] + \[Gamma] MSaddnfw[rn, rsn, \[Rho]s]; (*The total effective halo mass*)

VVSnfw[rn_, rsn_, \[Rho]s_, \[Gamma]_] = G/Rmax MSnfw[rn, rsn, \[Rho]s, \[Gamma]] /rn;

\[Delta]VSnfw[rn_, rsn_, \[Gamma]_] = FullSimplify[
  VVSnfw[rn, rsn, \[Rho]s, \[Gamma]] / VVSnfw[1, rsn, \[Rho]s, \[Gamma]],
  Assumptions -> {0 < rn < 1, 0 < rsn < 1, 0 < Rmax}
];


\[Gamma]min = -0.5;
\[Gamma]max = 1; (*I could have used \[Gamma]max = 2, but it gets far away from the observational data*)

n\[Gamma] = (\[Gamma]max - \[Gamma]min)/0.05 + 1;

plotSNFWGrayRed = Show[
  {
    plotBackground[2.0],
    plotSigmaRegionsRAR,
    Plot[
      {
        Evaluate@Table[\[Delta]VSnfw[rn, 10, X], {X, \[Gamma]min, \[Gamma]max, 0.05}], 
        Evaluate@Table[\[Delta]VSnfw[rn, 0.1, X], {X, \[Gamma]min, \[Gamma]max, 0.05}],
        \[Delta]VSnfw[rn, 0.1, 0],
        \[Delta]VSnfw[rn, 10, 0]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {Sequence@@Table[{Opacity[0.5], Thickness[0.01], ColorData["Rainbow"][i/n\[Gamma]]}, {i, n\[Gamma]}], Sequence@@Table[{Opacity[0.5], Thickness[0.01], ColorData["Rainbow"][i/n\[Gamma]]}, {i, n\[Gamma]}], {Black}, {Black}}
    ]
  }
]


\[Sigma]Silverman = 0.082; (*The vertical KDE "error". This value will not be crucial here, since it is constant.*)

Clear[chi2Upper, chi2Lower];
chi2Upper[rsn_?NumberQ, \[Gamma]_, n\[Sigma]_]:= chi2Upper[rsn, \[Gamma], n\[Sigma]] =  NIntegrate[
  (upperBound[n\[Sigma]][rn] - \[Delta]VSnfw[rn, rsn, \[Gamma]])^2/ \[Sigma]Silverman^2 ,
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];

chi2Lower[rsn_?NumberQ, \[Gamma]_, n\[Sigma]_] := chi2Lower[rsn, \[Gamma], n\[Sigma]] = NIntegrate[
  (lowerBound[n\[Sigma]][rn]- \[Delta]VSnfw[rn,rsn, \[Gamma]])^2/  \[Sigma]Silverman^2 , 
  {rn, rnStart, rnEnd}, 
  Method-> {Automatic, "SymbolicProcessing" -> 0},
  WorkingPrecision -> 10, 
  PrecisionGoal -> 3, 
  AccuracyGoal -> Infinity, 
  MaxRecursion -> 10
];


(* SPECIFIC DEFINITIONS *)

rnStart = 0.2;
rnEnd = 0.9;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

ClearAll[rsnUpper, rsnLower];
rsnUpper[2] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Upper[rsn, \[Gamma], 2], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];
rsnUpper[1] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Upper[rsn, \[Gamma], 1], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];
rsnLower[2] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Lower[rsn, \[Gamma], 2], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];
rsnLower[1] :=  {rsn, \[Gamma]} /. NMinimize[{chi2Lower[rsn, \[Gamma], 1], 50>rsn>0.1, \[Gamma]min < \[Gamma] < \[Gamma]max}, {rsn, \[Gamma]}][[2]];

{rsnUpperR[2], rsnUpperR[1], rsnLowerR[2], rsnLowerR[1]} = Parallelize[
  {rsnUpper[2], rsnUpper[1], rsnLower[2], rsnLower[1]}
];

Echo[{rsnUpperR[1], rsnLowerR[1]}, "{rsn, \[Gamma]} 1\[Sigma] bounds: "];
Echo[{rsnUpperR[2], rsnLowerR[2]}, "{rsn, \[Gamma]} 2\[Sigma] bounds: "];


plotSnfwGlobalBestFit = Show[
  {
    plotBurkertGrayRed /. {Dashed -> Dashing[.01], Black -> Red},
    plotNFWGrayRed /. {Dashed -> DotDashed, Black -> Orange},
    Plot[
      {
        \[Delta]VSnfw[rn, Sequence@@ rsnUpperR @ 2],
        \[Delta]VSnfw[rn, Sequence@@ rsnUpperR @ 1],
        \[Delta]VSnfw[rn, Sequence@@ rsnLowerR @ 2],
        \[Delta]VSnfw[rn, Sequence@@ rsnLowerR @ 1]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotSnfwGlobalBestFit:"];
Print@plotSnfwGlobalBestFit;

Export["plotSnfwGlobalBestFit.pdf", plotSnfwGlobalBestFit];


\[Gamma]best = -0.5;

plotSNFWglobalGammaGrayRed = Show[
  {
    plotBackground[1.5],
    plotSigmaRegionsRAR,
    Plot[
      {
        \[Delta]VSnfw[rn, 1000, \[Gamma]best], 
        \[Delta]VSnfw[rn, 0.001, \[Gamma]best]
      },
      {rn, 0, 1},
      PlotRange -> All,
      PlotStyle -> {{Thickness[0.005], Black, Dashed}}
    ]
  }
];

Echo["plotSNFWglobalGammaGrayRed:"];
Print@plotSNFWglobalGammaGrayRed;




(* SPECIFIC DEFINITIONS *)

rnStart = 0.01;
rnEnd=0.99;

lowerBound[1] = list1InterpCurvesRAR[[1]];
upperBound[1] = list1InterpCurvesRAR[[2]];
lowerBound[2] = list1InterpCurvesRAR[[3]];
upperBound[2] = list1InterpCurvesRAR[[4]];


(* EXECUTION *)

Echo["Performing the optimization."];

rsnUpper[2] = rsn /. NMinimize[{chi2Upper[rsn, \[Gamma]best, 2], rsn > 0}, {rsn, 0, 1}][[2]];
rsnUpper[1] = rsn /. NMinimize[{chi2Upper[rsn, \[Gamma]best, 1], rsn > 0}, {rsn, 0, 1}][[2]];
rsnLower[2] = rsn /. NMinimize[{chi2Lower[rsn, \[Gamma]best, 2], rsn > 0}, {rsn, 10, 1000}][[2]];
rsnLower[1] = rsn /. NMinimize[{chi2Lower[rsn, \[Gamma]best, 1], rsn > 0}, {rsn, 10, 1000}][[2]];

Echo[{rsnUpper[1], rsnLower[1]}, "rsn 1\[Sigma] bounds: "];
Echo[{rsnUpper[2], rsnLower[2]}, "rsn 2\[Sigma] bounds: "];

plotNFWGlobalGammaBestFit = Show[
  {
    plotSNFWglobalGammaGrayRed,
    Plot[
      {
        \[Delta]VSnfw[rn, rsnUpper @ 2, \[Gamma]best],
        \[Delta]VSnfw[rn, rsnUpper @ 1, \[Gamma]best],
        \[Delta]VSnfw[rn, rsnLower @ 2, \[Gamma]best],
        \[Delta]VSnfw[rn, rsnLower @ 1, \[Gamma]best]
      },
      {rn, 0, 1},
      PlotStyle -> {
        {Darker[Blue, 0.2], Thickness @ 0.003},
        {Lighter[Blue, 0.5], Thickness @ 0.003}
      },
      Filling -> {
        1 -> {{3}, Directive[Lighter[Blue, 0.5], Opacity @ 0.2]},
        2 -> {{4}, Directive[Lighter[Blue, 0.2], Opacity @ 0.2]}
      },
      PlotRange -> All
    ]
  }
];

Echo["plotNFWGlobalGammaBestFit:"];
Print@plotNFWGlobalGammaBestFit;

Export["plotNFWGlobalGammaBestFit.pdf", plotNFWGlobalGammaBestFit];


\[Delta]vP2g[rn_, hn_, fh_, frho_]= (rn ( E^(-(rn/hn))+  frho  fh E^(- fh rn/hn)))/( E^(-(1/hn))+  frho fh  E^(- fh /hn));
\[Delta]v2Palatini[rn_, gal_] := \[Delta]vP2g[rn, list1hn[[gal]], list1fh[[gal]], list1frho[[gal]]];
Show[plotBackground[4.0],
  plotSigmaRegionsRARNoBulge,
  Plot[Evaluate[\[Delta]v2Palatini[rn, #] & /@ Range@122], {rn, 0, 1}, 
PlotRange -> All, 
PlotStyle-> Directive[Opacity[0.1],Blue, Thick]]
]



Clear @ list2\[Delta]VVmodel;
list2\[Delta]VVmodel[gal_] := Table[{rn, \[Delta]v2Palatini[rn, gal]}, {rn, RandomReal[1, 350]}];
list2\[Delta]VVmodelAll = Flatten[DeleteCases[list2\[Delta]VVmodel /@ Range @ 122, {}], 1];

list2\[Delta]VVmodelAlllimit = Select[list2\[Delta]VVmodelAll, #[[2]] < 5 &]; (*Data points with \[Delta]v larger than 5 are not considered, too far...*)

distPalatini = distributionSilverman[list2\[Delta]VVmodelAlllimit, 400]; (*Due to the large dispersion of data points, 400 InpoterpolationPoints are used*)
pdfValuenSigmaPalatini[n_?NumberQ] := FindHDPDFValues[distPalatini, nSigmaProbability[n]];
(*plotBluePalatini = plotBlue[list2\[Delta]VVmodelAll, list1LimitsSigmaPalatini, {{xmin, xmax - 0.01}, {-0.5, 2.5}}, PlotRange -> {{0, 0.99}, {-0.5, 2.5}}] *)

Clear[plotPalatiniSigma];
plotPalatiniSigma[n_] := plotPalatiniSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaPalatini[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distPalatini, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotPalatiniCurves = Plot[
  Evaluate[\[Delta]v2Palatini[rn, #] & /@ Range@122], 
  {rn, 0, 1}, 
  PlotRange -> All, 
  PlotStyle -> Directive[Opacity[0.1],
  Blue, 
  Thick]
];

plotPalatiniContours = Show[
  {plotPalatiniSigma[1], 
  plotPalatiniSigma[2]}
];
  
Show[
  plotBackground[4.0],
  plotSigmaRegionsRARNoBulge,
  plotPalatiniCurves,
  plotPalatiniContours
]

Export["plotdeltaVPalatini.pdf", %];


DistributeDefinitions["NAVbaseCode`"];
DistributeDefinitions["NAVbaseCode`Private`"];

EchoTiming[
{rI[1], rD[1], rI[2], rD[2]} = Parallelize[{
  regionIntersection[plotPalatiniSigma[1],1], 
  regionDifference[plotPalatiniSigma[1],1],
  regionIntersection[plotPalatiniSigma[2],2],
  regionDifference[plotPalatiniSigma[2],2]
  }]
];

efficiencyNAV[1]
efficiencyNAV[2]
efficiencyNAVtotal[]


Clear[a0, \[CapitalDelta]VVmodel, VVmodel, \[Delta]VVmodel];

v2MondRaw[R_, gal_] := R kpc aBar[R, gal]/(1 - E^-Sqrt[RealAbs[aBar[R, gal]]/a0]);

\[CapitalDelta]v2MondRaw[R_, gal_] := v2MondRaw[R, gal] - aBar[R, gal] R kpc ;

\[Delta]v2MondRaw[rn_, gal_] := If[gdR["Rad", gal]=={}, 
  {}, 
  \[CapitalDelta]v2MondRaw[rn rmax[gal], gal] / \[CapitalDelta]v2MondRaw[rmax[gal], gal]
];

Echo[a0 = 1, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  Plot[
    Evaluate[\[Delta]v2MondRaw[rn, #]& /@ Range@175], {rn,0,1}, 
    PlotStyle-> Directive[Opacity[0.1],Blue, Thick], PlotRange -> All
  ]
]

If[ChoiceDialog["Save plotdeltaVmonda01.pdf?"], 
  Export["plotdeltaVmonda01.pdf", %],
  Echo["Plot not saved."];
]


Echo[a0 = 1. 10^-15, "a0 = "];
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  Plot[
    Evaluate[\[Delta]VVmodel[rn, #]& /@ Range@175], {rn,0,1},  
    PlotStyle -> Directive[Opacity[0.1], Blue, Thick], PlotRange -> All
  ]
]

If[ChoiceDialog["Save plotdeltaVmonda015.pdf?"], 
  Export["plotdeltaVmonda015.pdf", %],
  Echo["Plot not saved."];
]


a0 = 1.2 10^-13;
Clear @ list2\[Delta]VVmodel;
list2\[Delta]VVmodel[gal_] := If[
  gdR[Rad, gal] == {},
  {},
  Table[{rn, \[Delta]VVmodel[rn, gal]}, {rn, RandomReal[1,70]}]
];
list2\[Delta]VVmodelAll = Flatten[DeleteCases[list2\[Delta]VVmodel /@ Range @ 175, {}], 1];


distMondRaw = distributionSilverman @ list2\[Delta]VVmodelAll;

pdfValuenSigmaMondRaw[n_?NumberQ] := FindHDPDFValues[distMondRaw, nSigmaProbability[n]];

Clear[plotMondRawSigma];
plotMondRawSigma[n_] := plotMondRawSigma[n] = Block[{pdfValue, contourStyle},
  pdfValue = pdfValuenSigmaMondRaw[n];
  Which[
    n == 1, contourStyle = Directive[Purple, Dashed, Thick], 
    n == 2, contourStyle = Directive[Lighter @ Purple, Dashed],
    True, Automatic
  ];
  ContourPlot[
    PDF[distMondRaw, {x,y}] == pdfValue, 
    {x, 0, 1}, {y, -1, 5},
    PerformanceGoal -> "Quality", 
    ContourStyle -> contourStyle
  ]
];

plotMondRawCurves = Plot[
  Evaluate[\[Delta]vPalatini[rn, #] & /@ Range@122], 
  {rn, 0, 1}, 
  PlotRange -> All, 
  PlotStyle -> Directive[Opacity[0.1],
  Blue, 
  Thick]
];

plotPalatiniContours = Show[
  {plotPalatiniSigma[1], 
  plotPalatiniSigma[2]}
];
  
Show[
  plotBackground[4.0],
  plotSigmaRegionsRARNoBulge,
  plotPalatiniCurves,
  plotPalatiniContours
]

Export["plotdeltaVPalatini.pdf", %];


plotMondCurves = Plot[
  Evaluate[\[Delta]VVmodel[rn, #] & /@ Range@175], {rn, 0, 1}, 
  PlotRange -> All, PlotStyle -> Directive[Opacity[0.1],Blue, Thick]
];

plotMondContours = ContourPlot[
  {
    PDF[distMondRaw, {x,y}] == list1LimitsSigmaMondRaw[[1]], 
    PDF[distMondRaw, {x,y}] == list1LimitsSigmaMondRaw[[2]]
  }, 
  {x,0,1}, {y,-0.5, 1.5},  
  ContourStyle -> {Directive[Purple, Dashed, Thick], Directive[Lighter@Purple, Dashed]}
];

Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  plotMondCurves,
  plotMondContours
]

Export["plotdeltaVmondPrincipal.pdf", %];


Clear[a0, aNewtList, aNewt, \[CapitalDelta]VVmodel, rmax, interpolVbar, interpolVbarSquared, VVmodel, \[Delta]VVmodel];

rmax[gal_] := Last[gdR[Rad, gal]];

aNewtList[gal_]:=Block[{vvbar, aux},
  vvbar = squareSign[gdR[Vbar, gal]];
  (*vvbar = Total[{ squareSign[#1], 0.5 squareSign[#2], 0.6 squareSign[#3] }] & @@@ gdR[{Vgas, Vdisk, Vbulge},gal];*)
  aux = {gdR[Rad,gal], vvbar/(kpc gdR[Rad,gal])}\[Transpose];
  Prepend[aux, {0,0}]
];

aNewt[R_, gal_] := aNewt[R, gal] = Interpolation[aNewtList[gal], Method->"Spline", InterpolationOrder->2][R];

VVmodel[R_, gal_] := R kpc aNewt[R, gal]/(1 - E^-Sqrt[RealAbs[aNewt[R, gal]]/a0]);

\[CapitalDelta]VVmodel[R_, gal_] := VVmodel[R, gal] - aNewt[R, gal] R kpc ;

\[Delta]VVmodel[rn_, gal_] := If[gdR[Rad, gal]=={}, 
  {}, 
  \[CapitalDelta]VVmodel[rn rmax[gal], gal] / \[CapitalDelta]VVmodel[rmax[gal], gal]
];


a0 = 1;
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  Plot[
    Evaluate[\[Delta]VVmodel[rn, #]& /@ Range@175], {rn,0,1}, 
    PlotStyle-> Directive[Opacity[0.1],Blue, Thick], PlotRange -> All
  ]
]

Export["plotdeltaVmonda01.pdf", %];


a0 = 10^-15;
Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  Plot[
    Evaluate[\[Delta]VVmodel[rn, #]& /@ Range@175], {rn,0,1},  
    PlotStyle -> Directive[Opacity[0.1], Blue, Thick], PlotRange -> All
  ]
]

Export["plotdeltaVmonda015.pdf", %];


a0 = 1.2 10^-13;
Clear @ list2\[Delta]VVmodel;
list2\[Delta]VVmodel[gal_] := If[
  gdR[Rad, gal] == {},
  {},
  Table[{rn, \[Delta]VVmodel[rn, gal]}, {rn, RandomReal[1,70]}]
];
list2\[Delta]VVmodelAll = Flatten[DeleteCases[list2\[Delta]VVmodel /@ Range @ 175, {}], 1];


list1LimitsSigmaMondRaw = FindHDPDFValues[distributionSilverman @ list2\[Delta]VVmodelAll, oneAndTwoSigma];
plotBlueMondRaw = plotBlue[
  list2\[Delta]VVmodelAll, 
  list1LimitsSigmaMondRaw, 
  {{xmin, xmax - 0.01}, {-0.5, 1.5}}, 
  PlotRange -> {{0, 0.99}, {-0.5, 1.5}}
] 


distMondRaw =distributionSilverman @ list2\[Delta]VVmodelAll;

plotMondCurves = Plot[
  Evaluate[\[Delta]VVmodel[rn, #] & /@ Range@175], {rn, 0, 1}, 
  PlotRange -> All, PlotStyle -> Directive[Opacity[0.1],Blue, Thick]
];

plotMondContours = ContourPlot[
  {
    PDF[distMondRaw, {x,y}] == list1LimitsSigmaMondRaw[[1]], 
    PDF[distMondRaw, {x,y}] == list1LimitsSigmaMondRaw[[2]]
  }, 
  {x,0,1}, {y,-0.5, 1.5},  
  ContourStyle -> {Directive[Purple, Dashed, Thick], Directive[Lighter@Purple, Dashed]}
];

Show[
  plotBackground[1.5],
  plotSigmaRegionsRAR,
  plotMondCurves,
  plotMondContours
]

Export["plotdeltaVmondPrincipal.pdf", %];


Clear[a0, rn, datasetDisk, datasetGas, auxTab, list1\[Delta]VVMondExp, list2\[Delta]VVMondExpAux, VVbarExp, aNewtExp, VVMondExp, \[Delta]VVMondExp, numberGalaxies, nG, \[CapitalDelta]VVMondExp, rMax, dataGal];

datasetDisk = datasetExpVdiskNoBulge;
datasetGas = datasetExpVgasNoBulge;

numberGalaxies = Length @ datasetDisk;
nG = numberGalaxies; (*122 galaxies without Bulge*)

VVbarExp[R_, logSigma0_, h_, logSigmaGas0_, hgas_] := 0.5 vExp[R, logSigma0, h]^2 + vExp[R, logSigmaGas0, hgas]^2;

dataGal[gal_] := dataGal[gal] = {
  datasetDisk[gal, "logSigma0"], 
  datasetDisk[gal, "h"], 
  datasetGas[gal, "logSigma0Gas"], 
  datasetGas[gal, "hGas"]
};

rMax[gal_] := rMax[gal] = datasetDisk[gal, "rMax"];

VVbarExp[R_, gal_Integer] := VVbarExp[R, Sequence @@ dataGal[gal]];

aNewtExp[R_, gal_] :=  VVbarExp[R, gal]/ (R kpc);

VVMondExp[R_, gal_] :=  R kpc aNewtExp[R, gal]/(1 - E^-Sqrt[aNewtExp[R, gal] / a0]);

\[CapitalDelta]VVMondExp[R_, gal_] := VVMondExp[R, gal] - VVbarExp[R, gal];

\[Delta]VVMondExpAux[rn_, gal_Integer] := \[CapitalDelta]VVMondExp[rn rMax[gal], gal] / \[CapitalDelta]VVMondExp[rMax[gal], gal];

(*To speed up the plots, it is relevant to define \[Delta]VVMondExp from a list of interpolated functions (list1\[Delta]VVMondExp)*)
list1\[Delta]VVMondExp[rni_] = Block[
  {list2\[Delta]VVMondExpAux},
  list2\[Delta]VVMondExpAux[gali_] := Prepend[
    Table[{rni,\[Delta]VVMondExpAux[rni, gali]}, {rni, 0.05, 1, 0.05}], 
    {0,0}
  ];
  Table[
    Interpolation[list2\[Delta]VVMondExpAux[gali]][rni], 
  {gali, nG}
  ]
];

\[Delta]VVMondExp[rn_, gal_] :=  list1\[Delta]VVMondExp[rn][[gal]]



a0 = 1;
Show[
  plotBackground[1.5],
  plotSigmaRegionsRARNoBulge,
  Plot[
    Evaluate[\[Delta]VVMondExp[rn, #]& /@ Range @ nG], {rn,0,1}, 
    PlotStyle -> Directive[Opacity[0.1],Blue, Thick], PlotRange -> All
  ]
]

Export["plotdeltaVmondExpa01.pdf", %];


a0 = 10^-15;
Show[
  plotBackground[1.5],
  plotSigmaRegionsRARNoBulge,
  Plot[
    Evaluate[\[Delta]VVMondExp[rn, #]& /@ Range @ nG], {rn,0,1}, 
    PlotStyle -> Directive[Opacity[0.1], Blue, Thick], PlotRange -> All
  ]
]

Export["plotdeltaVmondExpa015.pdf", %];


a0 = 1.2 10^-13;
Clear @ list2\[Delta]VVmodel;
list2\[Delta]VVmodel[gal_] := Table[{rn, \[Delta]VVMondExp[rn, gal]}, {rn, RandomReal[1,70]}];
list2\[Delta]VVmodelAll = Flatten[DeleteCases[list2\[Delta]VVmodel /@ Range @ nG, {}], 1];
distMondExp =distributionSilverman@list2\[Delta]VVmodelAll;

list1LimitsSigmaMondExp = FindHDPDFValues[distMondExp, oneAndTwoSigma];



plotMondCurves = Plot[
  Evaluate[\[Delta]VVMondExp[rn, #] & /@ Range@ nG], {rn, 0, 1}, 
  PlotRange -> All, PlotStyle -> Directive[Opacity[0.1],Blue, Thick]
];

plotMondContours = ContourPlot[
  {
    PDF[distMondExp, {x,y}] == list1LimitsSigmaMondExp[[1]], 
    PDF[distMondExp, {x,y}] == list1LimitsSigmaMondExp[[2]]
  }, 
  {x,0,1}, {y,-0.5, 1.5},  
  ContourStyle -> {Directive[Purple, Dashed, Thick], Directive[Lighter@Purple, Dashed]}
];

Show[
  plotBackground[1.5],
  plotSigmaRegionsRARNoBulge,
  plotMondCurves,
  plotMondContours
]

Export["plotdeltaVmondExpPrincipal.pdf", %];


 (*phiDisk and phiGas come from Binney & Tremaine 2nd Ed., eq.(2.164a)*)
Clear[phiExpDisk, phiExpGal, phiExpGal, \[CapitalDelta]VVRGGR, \[Delta]VVRGGR]

phiExpDisk[R_,logSigma0_,h_] = Block[{y, logSigma0, h, R}, 
  y = R/(2 h);
  - 4 \[Pi] G0 10^logSigma0 R (BesselI[0,y] BesselK[1,y] - BesselI[1,y] BesselK[0,y])
];

phiExpGal[R_, logSigma0_, h_, logSigmaGas0_, hGas_] = 0.5 phiExpDisk[R, logSigma0, h] + phiExpDisk[R, logSigmaGas0, hGas];

phiExpGal[R_, gal_Integer] := phiExpGal[R, gal] = phiExpGal[R, Sequence @@ dataGal[gal]];

\[CapitalDelta]VVRGGR[R_, gal_] := - VVInfty VVbarExp[R, gal] / phiExpGal[R, gal];

\[Delta]VVRGGRAux[rn_, gal_Integer] := \[Delta]VVRGGRAux[rn, gal] =  \[CapitalDelta]VVRGGR[rn rMax[gal], gal] / \[CapitalDelta]VVRGGR[rMax[gal], gal];

(*To speed up the plots, it is relevant to define \[Delta]VVMondExp from a list of interpolated functions (list1\[Delta]VVMondExp)*)
l1\[Delta]VVRGGR[rni_] = Block[
  {l2\[Delta]VVRGGRAux},
  l2\[Delta]VVRGGRAux[gali_] := Prepend[
    Table[{rni, \[Delta]VVRGGRAux[rni, gali]}, {rni, 0.05, 1, 0.05}], 
    {0,0}
  ];
  Table[
    Interpolation[l2\[Delta]VVRGGRAux[gali]][rni], 
  {gali, nG}
  ]
];

\[Delta]VVRGGR[rn_, gal_] :=  l1\[Delta]VVRGGR[rn][[gal]]


l2\[Delta]VVRGGRdiscrete[gal_] := Table[{rn, \[Delta]VVRGGR[rn, gal]}, {rn, RandomReal[1,200]}];
l2\[Delta]VVRGGRdiscreteAll = Flatten[l2\[Delta]VVRGGRdiscrete /@ Range @ nG, 1];
distRGGR =distributionSilverman @ l2\[Delta]VVRGGRdiscreteAll;

l1LimitsSigmaRGGR = FindHDPDFValues[distRGGR, oneAndTwoSigma];



plotRGGRCurves = Plot[
  Evaluate[\[Delta]VVRGGR[rn, #] & /@ Range@ nG], {rn, 0, 1}, 
  PlotRange -> All, PlotStyle -> Directive[Opacity[0.1],Blue, Thick]
];

plotRGGRContours = ContourPlot[
  {
    PDF[distRGGR, {x,y}] == l1LimitsSigmaRGGR[[1]], 
    PDF[distRGGR, {x,y}] == l1LimitsSigmaRGGR[[2]]
  }, 
  {x,0,1}, {y,-0.5, 2.0},  
  ContourStyle -> {Directive[Purple, Dashed, Thick], Directive[Lighter@Purple, Dashed]}
];

Show[
  plotBackground[2.0],
  plotSigmaRegionsRARNoBulge,
  plotRGGRCurves,
  plotRGGRContours
]

Export["plotdeltaVRGGR.pdf", %];


\[Delta]vP2g[rn_, hn_, fh_, frho_]= (rn ( E^(-(rn/hn))+  frho  fh E^(- fh rn/hn)))/( E^(-(1/hn))+  frho fh  E^(- fh /hn));
\[Delta]vPalatini[rn_, gal_] := \[Delta]vP2g[rn, list1hn[[gal]], list1fh[[gal]], list1frho[[gal]]];
Show[plotBackground[2.5],
  plotSigmaRegionsRARNoBulge,
  Plot[Evaluate[\[Delta]vPalatini[rn, #] & /@ Range@122], {rn, 0, 1}, 
PlotRange -> All, 
PlotStyle-> Directive[Opacity[0.1],Blue, Thick]]
]


 (*phiDisk and phiGas come from Binney & Tremaine 2nd Ed., eq.(2.164a)*)
Clear[phiExpDisk, phiExpGal, phiExpGal, \[CapitalDelta]VVRGGR, \[Delta]VVRGGR]

phiExpDisk[R_,logSigma0_,h_] = Block[{y, logSigma0, h, R}, 
  y = R/(2 h);
  - 4 \[Pi] G0 10^logSigma0 R (BesselI[0,y] BesselK[1,y] - BesselI[1,y] BesselK[0,y])
];

phiExpGal[R_, logSigma0_, h_, logSigmaGas0_, hGas_] = 0.5 phiExpDisk[R, logSigma0, h] + phiExpDisk[R, logSigmaGas0, hGas];

phiExpGal[R_, gal_Integer] := phiExpGal[R, gal] = phiExpGal[R, Sequence @@ dataGal[gal]];

\[CapitalDelta]VVRGGR[R_, gal_] := - VVInfty VVbarExp[R, gal] / phiExpGal[R, gal];

\[Delta]VVRGGRAux[rn_, gal_Integer] := \[Delta]VVRGGRAux[rn, gal] =  \[CapitalDelta]VVRGGR[rn rMax[gal], gal] / \[CapitalDelta]VVRGGR[rMax[gal], gal];

(*To speed up the plots, it is relevant to define \[Delta]VVMondExp from a list of interpolated functions (list1\[Delta]VVMondExp)*)
l1\[Delta]VVRGGR[rni_] = Block[
  {l2\[Delta]VVRGGRAux},
  l2\[Delta]VVRGGRAux[gali_] := Prepend[
    Table[{rni, \[Delta]VVRGGRAux[rni, gali]}, {rni, 0.05, 1, 0.05}], 
    {0,0}
  ];
  Table[
    Interpolation[l2\[Delta]VVRGGRAux[gali]][rni], 
  {gali, nG}
  ]
];

\[Delta]VVRGGR[rn_, gal_] :=  l1\[Delta]VVRGGR[rn][[gal]]


\[Delta]Vobs1\[Sigma]L[xn_] =  list1InterpSigmaCurves[plotBlueRAR][[1]][xn]; (*L stands for lower limit*)
\[Delta]Vobs1\[Sigma]U[xn_] =  list1InterpSigmaCurves[plotBlueRAR][[2]][xn]; (*U stands for upper limit*)
\[Delta]Vobs2\[Sigma]L[xn_] =  list1InterpSigmaCurves[plotBlueRAR][[3]][xn];
\[Delta]Vobs2\[Sigma]U[xn_] =  list1InterpSigmaCurves[plotBlueRAR][[4]][xn];

positivePart[x_] := HeavisideTheta[x] x;

Clear[areaObs];
areaObs[numberOfSigmas_] := Which[
  numberOfSigmas == 1, NIntegrate[\[Delta]Vobs1\[Sigma]U[xn] - \[Delta]Vobs1\[Sigma]L[xn], {xn, 0.2, 0.9}],
  numberOfSigmas == 2, NIntegrate[\[Delta]Vobs2\[Sigma]U[xn] - \[Delta]Vobs2\[Sigma]L[xn], {xn, 0.2, 0.9}],
  True, Echo["Wrong number of sigmas specification. Aborting."]; Abort[]
];
  
efficiencyNAV[ModelSigmaL_, ModelSigmaU_, numberOfSigmas_Integer] := Block[ (*There is another efficiencyNAV function with different number of arguments.*)
  {
    areaIntersection,
    areaModelOut,
    xn, (*equivalent to rn, used to avoid definition clash*)
    \[Delta]VobsL,
    \[Delta]VobsU
  },
  
  Which[
    numberOfSigmas == 1, \[Delta]VobsL = \[Delta]Vobs1\[Sigma]L; \[Delta]VobsU = \[Delta]Vobs1\[Sigma]U,
    numberOfSigmas == 2, \[Delta]VobsL = \[Delta]Vobs2\[Sigma]L; \[Delta]VobsU = \[Delta]Vobs2\[Sigma]U,
    True, Echo["Wrong number of sigmas specification. Aborting."]; Abort[]
  ];
  
  areaIntersection = NIntegrate[
    Min[\[Delta]VobsU[xn], ModelSigmaU[xn]] - Max[\[Delta]VobsL[xn], ModelSigmaL[xn]],
    {xn, 0.2, 0.9}
  ] / areaObs[numberOfSigmas];
  
  areaModelOut = NIntegrate[
    positivePart[ModelSigmaU[xn] - \[Delta]VobsU[xn]] + positivePart[\[Delta]VobsL[xn] - ModelSigmaL[xn]],
    {xn, 0.2, 0.9}
  ]/ areaObs[numberOfSigmas];
  
  {areaIntersection - areaModelOut, areaIntersection, areaModelOut}
];

Clear @ efficiencyNAVtotal; (*There is another efficiencyNAVtotal function with different number of arguments.*)
efficiencyNAVtotal[ModelSigmaL1_, ModelSigmaU1_, ModelSigmaL2_, ModelSigmaU2_] := (
  efficiencyNAV[ModelSigmaL1, ModelSigmaU1, 1] + 
  efficiencyNAV[ModelSigmaL2, ModelSigmaU2, 2]
) / 2;


(* ContourPlots with the limiting sigma regions WITHOUT BULGE *)
Clear[plotObsSigma, plotRGGRSigma, plotMONDRawSigma, plotPalatiniSigma, plotMONDExpSigma];
plotObsSigma[n_] := plotObsSigma[n] = ContourPlot[
  PDF[distRARRotNoBulge, {x,y}] == list1LimitsNoBulge[[n]], {x, 0, 1}, {y, -0.5, 2},
  PerformanceGoal -> "Quality", PlotPoints -> 40, MaxRecursion -> 2
];
plotPalatiniSigma[n_] := plotPalatiniSigma[n] = ContourPlot[
  PDF[distPalatini, {x,y}] == list1LimitsSigmaPalatini[[n]], {x, 0, 1}, {y, -1, 5},
  PerformanceGoal -> "Quality", PlotPoints -> 40, MaxRecursion -> 2
];
plotMONDRawSigma[n_] := plotMONDRawSigma[n] = ContourPlot[
  PDF[distMondRaw, {x,y}] == list1LimitsSigmaMondRaw[[n]], {x, 0, 1}, {y, -0.5, 2},
  PerformanceGoal -> "Quality", PlotPoints -> 40, MaxRecursion -> 2
];
plotMONDExpSigma[n_] := plotMONDExpSigma[n] = ContourPlot[
  PDF[distMondExp, {x,y}] == list1LimitsSigmaMondExp[[n]], {x, 0, 1}, {y, -0.5, 2},
  PerformanceGoal -> "Quality", PlotPoints -> 40, MaxRecursion -> 2
];
plotRGGRSigma[n_] := plotRGGRSigma[n] = ContourPlot[
  PDF[distRGGR, {x,y}] == l1LimitsSigmaRGGR[[n]], {x, 0, 1}, {y, -0.5, 2.5},
  PerformanceGoal -> "Quality", PlotPoints -> 40, MaxRecursion -> 2
];


(*List of points, instead of ContourPlots, for the models whose limiting \[Sigma] regions come from functions*)
Clear[pointsBurkertSigma];
pointsBurkertSigma[n_] := pointsBurkertSigma[n] = {
  Table[{rn, \[Delta]Vbrkt[rn, rcnLower @ n]}, {rn, 0.01, 1, 0.001}],
  Table[{rn, \[Delta]Vbrkt[rn, rcnUpper @ n]}, {rn, 0.01, 1, 0.001}]
};

(* Functions to compute the NAV Efficiency *)
listExtractPoints[plot_] := Cases[
  Normal @ FullForm @ First @ plot,
  Line[pts_] :> pts,
  Infinity
];


Clear[polygonPrepare];
polygonPrepare[listExtractPoints_] := Block[
  {pointsAux, transformation},
  If[Length[listExtractPoints] == 2, Null, Echo["Data must be a list with two components, one for each curve."]; Abort[]];
  If[
    Round[listExtractPoints[[1,1,1]], 1] == Round[listExtractPoints[[2,1,1]], 1], (*Check if both parts of the data start either close to 1 or to 0.*)
    transformation = Reverse, (*If both parts start together, one will need to be reversed*)
    transformation = Identity
  ];
  pointsAux = Join[First @ listExtractPoints, transformation @ Last @ listExtractPoints ];
  Cases[pointsAux, {x_,y_} /; 0.2 < x < 0.9]
];

Clear[areaSigma];
areaSigma[plot_Graphics] := Area @ Polygon @ polygonPrepare @ listExtractPoints @ plot;

areaSigma[points_List] := Area @ Polygon @ polygonPrepare @ points ;

(*Running the plots definitions*)
Echo["Running the plots..."]; 
EchoTiming @ Table[{plotRGGRSigma[n], plotMONDExpSigma[n], plotMONDRawSigma[n], plotPalatiniSigma[n], plotObsSigma[n]}, {n,1,2}];

  


Clear[regionIntersection];
regionIntersection[plotModelSigma_, nSigma_] := RegionIntersection[
  Region @ Polygon @ polygonPrepare @ listExtractPoints @ plotModelSigma, 
  Region @ Polygon @ polygonPrepare @ listExtractPoints @ plotObsSigma[nSigma]
];

Clear[regionDifference];
regionDifference[plotModelSigma_, nSigma_] := RegionDifference[
  Region @ Polygon @ polygonPrepare @ listExtractPoints @ plotModelSigma, 
  Region @ Polygon @ polygonPrepare @ listExtractPoints @ plotObsSigma[nSigma]
];

(* Execution *)

CloseKernels[];
LaunchKernels[];

DistributeDefinitions[regionIntersection, regionDifference, plotMONDRawSigma[1], plotMONDExpSigma[1], plotRGGRSigma[1], plotPalatiniSigma[1], plotMONDRawSigma[2], plotMONDExpSigma[2], plotRGGRSigma[2], plotPalatiniSigma[2]];

listPlotsSubmit1 = {plotMONDRawSigma, plotMONDExpSigma, plotRGGRSigma, plotPalatiniSigma};
listPlotsSubmit2 = {plotMONDRawSigma, plotMONDExpSigma, plotRGGRSigma};

submit = Flatten[{
  ParallelSubmit[regionIntersection[#[1], 1]] & /@ listPlotsSubmit1, 
  ParallelSubmit[regionIntersection[#[2], 2]] & /@ listPlotsSubmit2, 
  ParallelSubmit[regionDifference[#[1], 1]] & /@ listPlotsSubmit1, 
  ParallelSubmit[regionDifference[#[2], 2]] & /@ listPlotsSubmit2 
}]

Echo["Computing regions intersections and differences... It may take a few minutes."];
EchoTiming[answer = WaitAll[submit]];

listModels1 = {MONDRaw, MONDExp, RGGR, Palatini};
listModels2 = {MONDRaw, MONDExp, RGGR};

Evaluate @ Flatten[{
  rI[#, 1] & /@ listModels1,
  rI[#, 2] & /@ listModels2,
  rD[#, 1] & /@ listModels1,
  rD[#, 2] & /@ listModels2
}] = answer;

Clear[efficiencyNAV, efficiencyNAVtotal];
efficiencyNAV[model_, nSigma_] := (Area @ rI[model, nSigma] - Area @ rD[model, nSigma]) / areaSigma @ plotObsSigma[nSigma];
efficiencyNAVtotal[model_] := (efficiencyNAV[model, 1] + efficiencyNAV[model, 2])/2;



